<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>6</epicId>
    <storyId>6.5</storyId>
    <title>Create Rotation State Management Module</title>
    <status>Draft</status>
    <generatedAt>2025-10-26T00:28:26</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>/home/snapiz/projects/github/timayz/imkitchen/docs/stories/story-6.5.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>backend developer</asA>
    <iWant>to implement rotation state tracking logic</iWant>
    <soThat>recipes are properly rotated across weeks without repetition violations</soThat>
    <tasks>
- [ ] Create rotation.rs module file (AC: 1)
  - [ ] Create `crates/meal_planning/src/rotation.rs`
  - [ ] Add `pub mod rotation;` to `crates/meal_planning/src/lib.rs`
  - [ ] Add module-level documentation explaining rotation rules

- [ ] Implement RotationState struct (AC: 2)
  - [ ] Define struct with fields: used_main_course_ids (Vec&lt;RecipeId&gt;), used_appetizer_ids (Vec&lt;RecipeId&gt;), used_dessert_ids (Vec&lt;RecipeId&gt;), cuisine_usage_count (HashMap&lt;Cuisine, u32&gt;), last_complex_meal_date (Option&lt;Date&gt;)
  - [ ] Add derives: Debug, Clone, Serialize, Deserialize, Encode, Decode
  - [ ] Implement RotationState::new() constructor initializing all fields to empty/zero
  - [ ] Add unit test for constructor

- [ ] Implement main course tracking methods (AC: 3, 4)
  - [ ] Implement mark_used_main_course(&amp;mut self, id: &amp;RecipeId) - pushes to used_main_course_ids
  - [ ] Implement is_main_course_used(&amp;self, id: &amp;RecipeId) -&gt; bool - checks if ID in used_main_course_ids
  - [ ] Add unit test: mark_used_main_course then verify is_main_course_used returns true
  - [ ] Add unit test: is_main_course_used returns false for unused ID

- [ ] Implement appetizer tracking methods (AC: 3, 5)
  - [ ] Implement mark_used_appetizer(&amp;mut self, id: &amp;RecipeId) - pushes to used_appetizer_ids
  - [ ] Implement reset_appetizers_if_all_used(&amp;mut self, available_count: usize) - clears used_appetizer_ids if len() &gt;= available_count
  - [ ] Add unit test: mark 3 appetizers, call reset with count=3, verify list cleared
  - [ ] Add unit test: mark 2 appetizers, call reset with count=3, verify list NOT cleared
  - [ ] Add edge case test: reset with available_count=0 (should not panic)

- [ ] Implement dessert tracking methods (AC: 3, 5)
  - [ ] Implement mark_used_dessert(&amp;mut self, id: &amp;RecipeId) - pushes to used_dessert_ids
  - [ ] Implement reset_desserts_if_all_used(&amp;mut self, available_count: usize) - clears used_dessert_ids if len() &gt;= available_count
  - [ ] Add unit test: mark 5 desserts, call reset with count=5, verify list cleared
  - [ ] Add unit test: mark 3 desserts, call reset with count=5, verify list NOT cleared
  - [ ] Add edge case test: reset with available_count=0 (should not panic)

- [ ] Implement cuisine variety tracking (AC: 6)
  - [ ] Implement increment_cuisine_usage(&amp;mut self, cuisine: &amp;Cuisine) - increments count in HashMap, inserting 0 if not present
  - [ ] Add unit test: increment same cuisine 3 times, verify count is 3
  - [ ] Add unit test: increment different cuisines, verify separate counts
  - [ ] Add helper method get_cuisine_usage(&amp;self, cuisine: &amp;Cuisine) -&gt; u32 for testing/algorithm use

- [ ] Implement complexity spacing tracking (AC: 7)
  - [ ] Implement update_last_complex_meal_date(&amp;mut self, date: Date) - sets last_complex_meal_date to Some(date)
  - [ ] Add unit test: call update_last_complex_meal_date, verify field updated
  - [ ] Add unit test: verify new() constructor leaves last_complex_meal_date as None

- [ ] Write comprehensive edge case tests (AC: 8, 9)
  - [ ] Test: mark_used_main_course with empty initial state
  - [ ] Test: is_main_course_used with empty list returns false
  - [ ] Test: reset_appetizers_if_all_used when list is empty (should not panic)
  - [ ] Test: increment_cuisine_usage when HashMap is empty (inserts correctly)
  - [ ] Test: all recipes exhausted scenario (mark all main courses, verify all return true for is_used)
  - [ ] Test: serialization round-trip with serde (serialize then deserialize, verify equality)
  - [ ] Test: bincode Encode/Decode round-trip (for evento event storage)

- [ ] Add integration documentation (AC: 1)
  - [ ] Add module documentation explaining: main courses NEVER repeat, appetizers/desserts CAN repeat after exhaustion
  - [ ] Add example usage in module doc showing typical flow: new() -&gt; mark_used -&gt; reset_if_all_used
  - [ ] Document that rotation state is stored in evento events and `meal_plan_rotation_state` table
    </tasks>
  </story>

  <acceptanceCriteria>
1. New file `crates/meal_planning/src/rotation.rs` created
2. RotationState::new() constructor implemented
3. Methods: mark_used_main_course, mark_used_appetizer, mark_used_dessert
4. Method: is_main_course_used (checks uniqueness)
5. Methods: reset_appetizers_if_all_used, reset_desserts_if_all_used
6. Method: increment_cuisine_usage
7. Method: update_last_complex_meal_date
8. Unit tests cover all rotation logic
9. Edge cases handled: empty lists, all recipes exhausted
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>/home/snapiz/projects/github/timayz/imkitchen/docs/architecture-update-meal-planning-enhancements.md</path>
        <title>Architecture Update - Meal Planning Enhancements</title>
        <section>1.1.3 RotationState (lines 113-118)</section>
        <snippet>
pub struct RotationState {
    used_main_course_ids: Vec&lt;RecipeId&gt;,     // MUST be unique across all weeks
    used_appetizer_ids: Vec&lt;RecipeId&gt;,       // Can repeat after all used once
    used_dessert_ids: Vec&lt;RecipeId&gt;,         // Can repeat after all used once
    cuisine_usage_count: HashMap&lt;Cuisine, u32&gt;, // Track variety
    last_complex_meal_date: Option&lt;Date&gt;,    // Avoid consecutive complex meals
}
        </snippet>
      </doc>
      <doc>
        <path>/home/snapiz/projects/github/timayz/imkitchen/docs/architecture-update-meal-planning-enhancements.md</path>
        <title>Architecture Update - Meal Planning Enhancements</title>
        <section>10.5.5 Rotation State Management (lines 1055-1086)</section>
        <snippet>
impl RotationState {
    // Main courses: MUST be unique across all weeks
    pub fn mark_used_main_course(&amp;mut self, id: &amp;RecipeId) {
        self.used_main_course_ids.push(id.clone());
    }

    pub fn is_main_course_used(&amp;self, id: &amp;RecipeId) -&gt; bool {
        self.used_main_course_ids.contains(id)
    }

    // Appetizers/Desserts: Can repeat after all used once
    pub fn mark_used_appetizer(&amp;mut self, id: &amp;RecipeId) {
        self.used_appetizer_ids.push(id.clone());
    }

    pub fn reset_appetizers_if_all_used(&amp;mut self, total_count: usize) {
        if self.used_appetizer_ids.len() &gt;= total_count {
            self.used_appetizer_ids.clear();
        }
    }

    // Similar for desserts...

    // Cuisine variety tracking
    pub fn increment_cuisine_usage(&amp;mut self, cuisine: &amp;Cuisine) {
        *self.cuisine_usage_count.entry(cuisine.clone()).or_insert(0) += 1;
    }
}
        </snippet>
      </doc>
      <doc>
        <path>/home/snapiz/projects/github/timayz/imkitchen/docs/architecture-update-meal-planning-enhancements.md</path>
        <title>Architecture Update - Meal Planning Enhancements</title>
        <section>3.9.2 Rotation Rules (lines 392-394)</section>
        <snippet>
**Rotation Rules:**
- Main courses MUST be unique across all generated weeks (existing rule)
- Accompaniments CAN repeat (not subject to uniqueness constraint)
        </snippet>
      </doc>
      <doc>
        <path>/home/snapiz/projects/github/timayz/imkitchen/docs/architecture-update-meal-planning-enhancements.md</path>
        <title>Architecture Update - Meal Planning Enhancements</title>
        <section>4.5 New Table: meal_plan_rotation_state (lines 852-877)</section>
        <snippet>
CREATE TABLE meal_plan_rotation_state (
  id TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  generation_batch_id TEXT NOT NULL,
  used_main_course_ids TEXT NOT NULL,  -- JSON array
  used_appetizer_ids TEXT NOT NULL,    -- JSON array
  used_dessert_ids TEXT NOT NULL,      -- JSON array
  cuisine_usage_count TEXT NOT NULL,   -- JSON object
  last_complex_meal_date TEXT,         -- ISO 8601 date or NULL
  created_at TEXT NOT NULL,
  updated_at TEXT NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id)
);
        </snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/rotation.rs</path>
        <kind>module</kind>
        <symbol>RotationState</symbol>
        <lines>1-621</lines>
        <reason>Existing rotation module - already implements most of Story 6.5 requirements including mark_used_main_course, mark_used_appetizer, mark_used_dessert, is_main_course_used, increment_cuisine_usage, get_cuisine_usage, and update_last_complex_meal_date. Missing: reset_appetizers_if_all_used and reset_desserts_if_all_used methods.</reason>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/lib.rs</path>
        <kind>module</kind>
        <symbol>rotation module export</symbol>
        <lines>8, 26</lines>
        <reason>Module already exported in lib.rs - pub mod rotation; and pub use rotation::{RotationState, RotationSystem};</reason>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/recipe/src/types.rs</path>
        <kind>type</kind>
        <symbol>Cuisine</symbol>
        <lines>56-80</lines>
        <reason>Cuisine enum used in rotation state for tracking cuisine variety - imported via recipe crate</reason>
      </artifact>
    </code>
    <dependencies>
      <rust>
        <package name="serde" version="1.0" features="derive"/>
        <package name="bincode" version="2.0"/>
        <package name="chrono" version="0.4" features="serde"/>
        <package name="std::collections::HashMap"/>
        <package name="std::collections::HashSet"/>
        <package name="recipe" path="../recipe" note="For Cuisine type"/>
      </rust>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint id="1">
      <type>Architecture</type>
      <description>RotationState must be serializable via serde (JSON) and bincode (evento events)</description>
      <source>Dev Notes - Technical Constraints</source>
    </constraint>
    <constraint id="2">
      <type>Business Logic</type>
      <description>Main courses MUST be unique across ALL generated weeks (strict uniqueness constraint)</description>
      <source>Architecture - Section 3.9.2 Rotation Rules</source>
    </constraint>
    <constraint id="3">
      <type>Business Logic</type>
      <description>Appetizers CAN repeat after all available appetizers used once (soft rotation)</description>
      <source>Architecture - Section 3.9.2 Rotation Rules</source>
    </constraint>
    <constraint id="4">
      <type>Business Logic</type>
      <description>Desserts CAN repeat after all available desserts used once (soft rotation)</description>
      <source>Architecture - Section 3.9.2 Rotation Rules</source>
    </constraint>
    <constraint id="5">
      <type>Business Logic</type>
      <description>Accompaniments NOT tracked in rotation state (can repeat freely)</description>
      <source>Architecture - Section 3.9.2 Rotation Rules</source>
    </constraint>
    <constraint id="6">
      <type>Performance</type>
      <description>O(n) lookups acceptable for favorite recipe counts (typically &lt;50 per category)</description>
      <source>Dev Notes - Technical Constraints</source>
    </constraint>
    <constraint id="7">
      <type>Testing</type>
      <description>Test coverage target: &gt;90% per Story 6.7</description>
      <source>Dev Notes - Testing Standards</source>
    </constraint>
    <constraint id="8">
      <type>DDD Pattern</type>
      <description>Pure business logic - no database, no HTTP dependencies in this module</description>
      <source>Dev Notes - Alignment with Unified Structure</source>
    </constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>RotationState::new</name>
      <kind>constructor</kind>
      <signature>pub fn new() -&gt; Self</signature>
      <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/rotation.rs</path>
      <note>Already implemented - returns RotationState with all fields initialized to empty/zero/None</note>
    </interface>
    <interface>
      <name>RotationState::mark_used_main_course</name>
      <kind>method</kind>
      <signature>pub fn mark_used_main_course(&amp;mut self, recipe_id: &amp;str)</signature>
      <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/rotation.rs</path>
      <note>Already implemented - adds recipe_id to used_main_course_ids if not already present</note>
    </interface>
    <interface>
      <name>RotationState::mark_used_appetizer</name>
      <kind>method</kind>
      <signature>pub fn mark_used_appetizer(&amp;mut self, recipe_id: &amp;str)</signature>
      <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/rotation.rs</path>
      <note>Already implemented - pushes recipe_id to used_appetizer_ids (allows duplicates)</note>
    </interface>
    <interface>
      <name>RotationState::mark_used_dessert</name>
      <kind>method</kind>
      <signature>pub fn mark_used_dessert(&amp;mut self, recipe_id: &amp;str)</signature>
      <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/rotation.rs</path>
      <note>Already implemented - pushes recipe_id to used_dessert_ids (allows duplicates)</note>
    </interface>
    <interface>
      <name>RotationState::is_main_course_used</name>
      <kind>method</kind>
      <signature>pub fn is_main_course_used(&amp;self, recipe_id: &amp;str) -&gt; bool</signature>
      <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/rotation.rs</path>
      <note>Already implemented - checks if recipe_id is in used_main_course_ids vector</note>
    </interface>
    <interface>
      <name>RotationState::increment_cuisine_usage</name>
      <kind>method</kind>
      <signature>pub fn increment_cuisine_usage(&amp;mut self, cuisine: &amp;Cuisine)</signature>
      <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/rotation.rs</path>
      <note>Already implemented - increments count in HashMap using entry().or_insert(0) pattern</note>
    </interface>
    <interface>
      <name>RotationState::get_cuisine_usage</name>
      <kind>method</kind>
      <signature>pub fn get_cuisine_usage(&amp;self, cuisine: &amp;Cuisine) -&gt; u32</signature>
      <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/rotation.rs</path>
      <note>Already implemented - returns usage count for cuisine, 0 if not present</note>
    </interface>
    <interface>
      <name>RotationState::update_last_complex_meal_date</name>
      <kind>method</kind>
      <signature>pub fn update_last_complex_meal_date(&amp;mut self, date: &amp;str)</signature>
      <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/rotation.rs</path>
      <note>Already implemented - sets last_complex_meal_date to Some(date.to_string())</note>
    </interface>
    <interface>
      <name>RotationState::to_json</name>
      <kind>method</kind>
      <signature>pub fn to_json(&amp;self) -&gt; Result&lt;String, serde_json::Error&gt;</signature>
      <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/rotation.rs</path>
      <note>Already implemented - serializes to JSON for database storage</note>
    </interface>
    <interface>
      <name>RotationState::from_json</name>
      <kind>method</kind>
      <signature>pub fn from_json(json: &amp;str) -&gt; Result&lt;Self, serde_json::Error&gt;</signature>
      <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/rotation.rs</path>
      <note>Already implemented - deserializes from JSON</note>
    </interface>
    <interface>
      <name>Cuisine enum</name>
      <kind>type</kind>
      <signature>pub enum Cuisine { Italian, Indian, Mexican, Chinese, Japanese, French, Thai, Mediterranean, American, Custom(String) }</signature>
      <path>/home/snapiz/projects/github/timayz/imkitchen/crates/recipe/src/types.rs</path>
      <note>Imported from recipe crate - used for cuisine_usage_count HashMap</note>
    </interface>
  </interfaces>

  <tests>
    <standards>
The meal_planning crate uses Rust's built-in testing framework with #[cfg(test)] modules. Tests are co-located with implementation code in the same file. The existing rotation.rs module already has comprehensive unit tests (lines 273-621) covering basic rotation state functionality. Tests use standard assert! macros and follow the pattern: test_&lt;feature&gt;_&lt;scenario&gt;. The crate also has integration tests in the tests/ directory for end-to-end scenarios. All tests support async/await with #[tokio::test] for async operations. Testing follows DDD principles - domain logic tests are pure unit tests without database dependencies.
    </standards>
    <locations>
      <location>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/rotation.rs (lines 273-621 - existing unit tests)</location>
      <location>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/tests/ (integration tests directory)</location>
      <location>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/tests/rotation_integration_tests.rs (existing rotation integration tests)</location>
    </locations>
    <ideas>
      <test ac="5" description="Test reset_appetizers_if_all_used clears list when len() &gt;= available_count">
        - Mark 3 appetizers as used
        - Call reset_appetizers_if_all_used(3)
        - Assert used_appetizer_ids is empty
      </test>
      <test ac="5" description="Test reset_appetizers_if_all_used does NOT clear when len() &lt; available_count">
        - Mark 2 appetizers as used
        - Call reset_appetizers_if_all_used(3)
        - Assert used_appetizer_ids still has 2 items
      </test>
      <test ac="5" description="Test reset_desserts_if_all_used clears list when len() &gt;= available_count">
        - Mark 5 desserts as used
        - Call reset_desserts_if_all_used(5)
        - Assert used_dessert_ids is empty
      </test>
      <test ac="5" description="Test reset_desserts_if_all_used does NOT clear when len() &lt; available_count">
        - Mark 3 desserts as used
        - Call reset_desserts_if_all_used(5)
        - Assert used_dessert_ids still has 3 items
      </test>
      <test ac="9" description="Edge case: reset with available_count=0 for appetizers">
        - Call reset_appetizers_if_all_used(0)
        - Should not panic
        - List should be cleared (0 &gt;= 0)
      </test>
      <test ac="9" description="Edge case: reset with available_count=0 for desserts">
        - Call reset_desserts_if_all_used(0)
        - Should not panic
        - List should be cleared (0 &gt;= 0)
      </test>
      <test ac="8" description="Serialization round-trip test with serde">
        - Create RotationState with all fields populated
        - Serialize with to_json()
        - Deserialize with from_json()
        - Assert equality of all fields
      </test>
      <test ac="8" description="Bincode encode/decode round-trip test">
        - Create RotationState with all fields populated
        - Encode with bincode::encode_to_vec()
        - Decode with bincode::decode_from_slice()
        - Assert equality for evento event storage compatibility
      </test>
    </ideas>
  </tests>
</story-context>
