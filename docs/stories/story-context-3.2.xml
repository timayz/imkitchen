<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>3</epicId>
    <storyId>2</storyId>
    <title>Multi-Factor Meal Planning Algorithm</title>
    <status>Draft</status>
    <generatedAt>2025-10-16</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>/home/snapiz/projects/github/timayz/imkitchen/docs/stories/story-3.2.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>system</asA>
    <iWant>to optimize meal assignments based on multiple factors</iWant>
    <soThat>meal plans are realistic and achievable for users</soThat>
    <tasks>
      <task id="1">Implement Constraint Satisfaction Framework (AC: 1-9)</task>
      <task id="2">Enhance RecipeComplexityCalculator with Full Scoring (AC: 2)</task>
      <task id="3">Implement Weighted Recipe-to-Slot Scoring (AC: 1-9)</task>
      <task id="4">Implement CSP Solver for Meal Assignment (AC: 1-9)</task>
      <task id="5">Implement Advance Prep Lead Time Scheduling (AC: 5)</task>
      <task id="6">Implement Ingredient Freshness Constraint (AC: 7)</task>
      <task id="7">Implement Equipment Conflict Detection (AC: 8)</task>
      <task id="8">Implement Deterministic Randomization for Variety (AC: 9)</task>
      <task id="9">Validate Algorithm Output Against All Constraints (AC: 1-9)</task>
      <task id="10">Integration with MealPlanGenerated Event (References Story 3.1)</task>
      <task id="11">Performance Testing and Optimization (AC: NFR from tech spec)</task>
      <task id="12">Write Comprehensive Test Suite (TDD Required)</task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <ac id="1">Algorithm analyzes user profile: weeknight availability, cooking skill level, household size</ac>
    <ac id="2">Recipes scored on complexity: ingredient count, instruction steps, advance prep requirements</ac>
    <ac id="3">Complex recipes assigned to days with more availability (weekends, evenings with &gt;60min)</ac>
    <ac id="4">Simple recipes assigned to busy weeknights (&lt;45min availability)</ac>
    <ac id="5">Advance prep recipes scheduled to allow proper lead time (4-hour marinade on Tue for Wed dinner)</ac>
    <ac id="6">Recipe dietary tags matched against user dietary restrictions (no shellfish if allergic)</ac>
    <ac id="7">Ingredient freshness considered (produce-heavy meals earlier in week)</ac>
    <ac id="8">Equipment conflicts avoided (no two oven-dependent meals back-to-back)</ac>
    <ac id="9">Algorithm deterministic but varied (same inputs produce different valid plans on regeneration)</ac>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/tech-spec-epic-3.md</path>
        <title>Technical Specification: Intelligent Meal Planning Engine</title>
        <section>MealPlanningAlgorithm (Core Domain Service)</section>
        <snippet>Multi-factor constraint satisfaction solver for recipe-to-slot assignment. Algorithm considers 7 constraint types: availability, complexity, advance prep, dietary, freshness, equipment, rotation. Weighted scoring: complexity_fit (40%) + time_fit (40%) + freshness_fit (20%). Performance: O(n) complexity, &lt;5 second target for 50 recipes.</snippet>
        <relevance>Defines core algorithm architecture, constraint types, scoring weights, and performance requirements for this story</relevance>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-3.md</path>
        <title>Technical Specification: Intelligent Meal Planning Engine</title>
        <section>RecipeComplexityCalculator (Domain Service)</section>
        <snippet>Formula: complexity_score = (ingredients * 0.3) + (steps * 0.4) + (advance_prep_multiplier * 0.3). Mapping: &lt;30 = Simple, 30-60 = Moderate, &gt;60 = Complex. advance_prep_multiplier: 0 (none), 50 (&lt;4hr), 100 (≥4hr).</snippet>
        <relevance>Specifies exact complexity calculation formula required for AC-2</relevance>
      </doc>
      <doc>
        <path>docs/solution-architecture.md</path>
        <title>Solution Architecture Document</title>
        <section>Domain Crate Structure (11.1)</section>
        <snippet>Domain crates organized as DDD bounded contexts. meal_planning crate structure: aggregate.rs (MealPlan aggregate), commands.rs, events.rs, algorithm.rs (domain services), rotation.rs, read_model.rs. All business logic in domain crates, routes are thin handlers.</snippet>
        <relevance>Defines where to implement constraint logic (algorithm.rs, new constraints.rs module)</relevance>
      </doc>
      <doc>
        <path>docs/solution-architecture.md</path>
        <title>Solution Architecture Document</title>
        <section>Testing Strategy (15)</section>
        <snippet>TDD enforced: write tests first. Unit tests for domain logic in crates/*/tests/. Integration tests for HTTP routes in tests/. E2E tests with Playwright in e2e/. Target: 80% code coverage. cargo tarpaulin for coverage measurement.</snippet>
        <relevance>Defines testing requirements for Task 12</relevance>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>imkitchen - Epic Breakdown</title>
        <section>Story 3.2: Multi-Factor Meal Planning Algorithm</section>
        <snippet>Algorithm analyzes user profile constraints, scores recipes on complexity, assigns complex recipes to high-availability days, simple recipes to weeknights, schedules advance prep with lead time, matches dietary restrictions, considers ingredient freshness, avoids equipment conflicts, and provides deterministic but varied assignments.</snippet>
        <relevance>Source of acceptance criteria and story definition</relevance>
      </doc>
      <doc>
        <path>docs/stories/story-3.1.md</path>
        <title>Story 3.1: Generate Initial Meal Plan</title>
        <section>Completion Notes</section>
        <snippet>Core domain implemented: MealPlan aggregate with evento, basic MealPlanningAlgorithm with RecipeComplexityCalculator (simple scoring), RotationSystem. Algorithm generates 21 assignments (7 days × 3 meals). 15 passing unit tests. Story marked Complete.</snippet>
        <relevance>Story 3.2 extends the algorithm created in Story 3.1 with full constraint satisfaction logic</relevance>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>crates/meal_planning/src/algorithm.rs</path>
        <kind>module</kind>
        <symbol>RecipeComplexityCalculator</symbol>
        <lines>73-110</lines>
        <reason>Existing complexity calculator with basic scoring - needs enhancement for full AC-2 implementation with proper thresholds and advance prep multipliers</reason>
      </artifact>
      <artifact>
        <path>crates/meal_planning/src/algorithm.rs</path>
        <kind>module</kind>
        <symbol>MealPlanningAlgorithm</symbol>
        <lines>126-250</lines>
        <reason>Core algorithm structure exists from Story 3.1 - needs extension with constraint satisfaction framework, weighted scoring, CSP solver logic</reason>
      </artifact>
      <artifact>
        <path>crates/meal_planning/src/algorithm.rs</path>
        <kind>struct</kind>
        <symbol>RecipeForPlanning</symbol>
        <lines>9-18</lines>
        <reason>Recipe data structure for algorithm - contains complexity inputs (ingredients_count, instructions_count, advance_prep_hours)</reason>
      </artifact>
      <artifact>
        <path>crates/meal_planning/src/algorithm.rs</path>
        <kind>struct</kind>
        <symbol>UserConstraints</symbol>
        <lines>22-36</lines>
        <reason>User profile constraints structure - contains weeknight_availability_minutes, skill_level, dietary_restrictions used in constraint evaluation</reason>
      </artifact>
      <artifact>
        <path>crates/meal_planning/src/rotation.rs</path>
        <kind>module</kind>
        <symbol>RotationSystem</symbol>
        <lines>69-110</lines>
        <reason>Rotation constraint already implemented - use RotationSystem::filter_available_recipes() to apply rotation constraint in CSP solver</reason>
      </artifact>
      <artifact>
        <path>crates/meal_planning/src/events.rs</path>
        <kind>struct</kind>
        <symbol>MealAssignment</symbol>
        <lines>36-48</lines>
        <reason>Output structure for algorithm - includes prep_required flag (AC-5) and assignment_reasoning field (for transparency)</reason>
      </artifact>
      <artifact>
        <path>crates/meal_planning/src/read_model.rs</path>
        <kind>module</kind>
        <symbol>MealPlanQueries</symbol>
        <lines>38-192</lines>
        <reason>Query methods for fetching user profile and favorite recipes - use in route handler to pass data to algorithm</reason>
      </artifact>
      <artifact>
        <path>src/routes/meal_plan.rs</path>
        <kind>module</kind>
        <symbol>generate_meal_plan</symbol>
        <lines>115-210</lines>
        <reason>HTTP route handler that invokes algorithm - modify to pass full UserConstraints (not just basic profile)</reason>
      </artifact>
    </code>
    <dependencies>
      <ecosystem name="rust-cargo">
        <package name="evento" version="1.4" purpose="Event sourcing framework for MealPlan aggregate"/>
        <package name="sqlx" version="0.8" purpose="Database queries for user profile and recipes"/>
        <package name="chrono" version="0.4" purpose="Date/time handling for meal slots and advance prep scheduling"/>
        <package name="serde" version="1.0" purpose="JSON serialization for rotation state and constraints"/>
        <package name="bincode" version="2.0" purpose="Event serialization for evento"/>
        <package name="anyhow" version="1.0" purpose="Error handling"/>
        <package name="thiserror" version="1.0" purpose="Domain error definitions"/>
      </ecosystem>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>All domain logic must reside in crates/meal_planning/ domain crate, not in HTTP route handlers</constraint>
    <constraint>Event sourcing with evento: emit MealPlanGenerated event with assignments including assignment_reasoning</constraint>
    <constraint>TDD enforced: write tests first for each constraint type before implementing</constraint>
    <constraint>Performance target: Algorithm must complete in &lt;5 seconds for 50 recipes (O(n) complexity)</constraint>
    <constraint>Constraint satisfaction: All hard constraints (dietary, rotation) must be satisfied; soft constraints (complexity-to-day match) optimized</constraint>
    <constraint>Complexity formula per tech spec: (ingredients * 0.3) + (steps * 0.4) + (advance_prep_multiplier * 0.3) with thresholds &lt;30 Simple, 30-60 Moderate, &gt;60 Complex</constraint>
    <constraint>Weighted scoring: complexity_fit (40%) + time_fit (40%) + freshness_fit (20%)</constraint>
    <constraint>Deterministic randomization: Use seed for shuffle to produce varied but reproducible assignments</constraint>
    <constraint>Integration with Story 3.1: Extend existing MealPlanningAlgorithm and RecipeComplexityCalculator, don't replace</constraint>
    <constraint>Target 80% code coverage via cargo tarpaulin</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>RotationSystem::filter_available_recipes</name>
      <kind>function</kind>
      <signature>pub fn filter_available_recipes(recipes: Vec&lt;RecipeForPlanning&gt;, rotation_state: &amp;RotationState) -&gt; Vec&lt;RecipeForPlanning&gt;</signature>
      <path>crates/meal_planning/src/rotation.rs:75-87</path>
      <usage>Use in CSP solver to apply rotation constraint (filter out used recipes)</usage>
    </interface>
    <interface>
      <name>RecipeComplexityCalculator::calculate_complexity</name>
      <kind>function</kind>
      <signature>pub fn calculate_complexity(recipe: &amp;RecipeForPlanning) -&gt; Complexity</signature>
      <path>crates/meal_planning/src/algorithm.rs:93-110</path>
      <usage>Existing complexity calculator - enhance with correct thresholds and advance prep multipliers per tech spec</usage>
    </interface>
    <interface>
      <name>MealPlanningAlgorithm::generate</name>
      <kind>function</kind>
      <signature>pub fn generate(user_id: String, start_date: NaiveDate, recipes: Vec&lt;RecipeForPlanning&gt;, user_constraints: UserConstraints, rotation_state: RotationState) -&gt; Result&lt;(Vec&lt;MealAssignment&gt;, RotationState), MealPlanningError&gt;</signature>
      <path>crates/meal_planning/src/algorithm.rs:140-251</path>
      <usage>Core algorithm entry point - extend with constraint framework and CSP solver</usage>
    </interface>
    <interface>
      <name>MealPlanQueries::get_active_meal_plan_with_assignments</name>
      <kind>function</kind>
      <signature>pub async fn get_active_meal_plan_with_assignments(user_id: &amp;str, pool: &amp;SqlitePool) -&gt; Result&lt;Option&lt;MealPlanWithAssignments&gt;, sqlx::Error&gt;</signature>
      <path>crates/meal_planning/src/read_model.rs:63-130</path>
      <usage>Query method to fetch existing meal plan and rotation state</usage>
    </interface>
    <interface>
      <name>evento::create</name>
      <kind>macro</kind>
      <signature>evento::create::&lt;MealPlanAggregate&gt;().data(&amp;MealPlanGenerated{...}).metadata(&amp;user_id).commit(&amp;executor).await</signature>
      <path>External: evento crate</path>
      <usage>Create MealPlan aggregate with MealPlanGenerated event after algorithm execution</usage>
    </interface>
  </interfaces>

  <tests>
    <standards>
      TDD strictly enforced per solution architecture. Write tests first, then implementation. Three test layers required:
      1. **Unit tests** in crates/meal_planning/tests/ - Test each constraint type independently (AvailabilityConstraint, ComplexityConstraint, etc.), test RecipeComplexityCalculator scoring formula, test MealPlanningAlgorithm::score_recipe_for_slot weighted scoring
      2. **Integration tests** in tests/meal_plan_algorithm_integration_tests.rs - Test full algorithm with real user profile and 21 recipes, verify all constraints satisfied, test rotation persistence across generations
      3. **Performance tests** - Benchmark with 50 recipes, assert &lt;5 second completion, use cargo bench or criterion

      Framework: cargo test for unit/integration, cargo tarpaulin for coverage (target 80%). Use assert!, assert_eq!, assert!(result.is_ok()), etc.
    </standards>
    <locations>
      <location>crates/meal_planning/tests/constraints_tests.rs (new file for constraint unit tests)</location>
      <location>crates/meal_planning/tests/algorithm_tests.rs (extend existing file)</location>
      <location>tests/meal_plan_algorithm_integration_tests.rs (new file)</location>
    </locations>
    <ideas>
      <test ac="1">Unit test: UserConstraints with weeknight_availability_minutes=45 filters recipes with total_time &gt; 45 for weeknight slots</test>
      <test ac="2">Unit test: RecipeComplexityCalculator with 5 ingredients, 4 steps, 0 prep → score &lt; 30 → Complexity::Simple</test>
      <test ac="2">Unit test: RecipeComplexityCalculator with 10 ingredients, 8 steps, 0 prep → score 30-60 → Complexity::Moderate</test>
      <test ac="2">Unit test: RecipeComplexityCalculator with 5 ingredients, 4 steps, 4-hour marinade → score &gt; 60 → Complexity::Complex</test>
      <test ac="3">Unit test: ComplexityConstraint assigns Complex recipe (15+ ingredients) to Saturday/Sunday (weekend)</test>
      <test ac="4">Unit test: ComplexityConstraint assigns Simple recipe (7 ingredients, 5 steps) to Tuesday (weeknight with 45min availability)</test>
      <test ac="5">Unit test: AdvancePrepConstraint schedules 4-hour marinade recipe on Wednesday dinner with prep_required flag set and reasoning "Prep on Tuesday evening for Wednesday dinner"</test>
      <test ac="6">Unit test: DietaryConstraint filters recipes tagged "shellfish" for user with dietary_restrictions=["no-shellfish"]</test>
      <test ac="7">Unit test: FreshnessConstraint assigns seafood recipe to Monday-Wednesday (days 1-3)</test>
      <test ac="8">Unit test: EquipmentConflictConstraint prevents two oven recipes on same day</test>
      <test ac="9">Unit test: Same seed produces identical meal plan twice; different seeds produce different valid plans</test>
      <test ac="1-9">Integration test: Generate meal plan with 21 recipes, verify all 21 slots assigned, all constraints satisfied, rotation state updated</test>
      <test ac="performance">Performance test: Algorithm with 50 recipes completes in &lt;5 seconds</test>
    </ideas>
  </tests>
</story-context>
