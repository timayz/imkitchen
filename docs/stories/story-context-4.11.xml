<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>4</epicId>
    <storyId>11</storyId>
    <title>Ingredient Quantity Aggregation Logic</title>
    <status>Draft</status>
    <generatedAt>2025-10-18</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>/home/snapiz/projects/github/timayz/imkitchen/docs/stories/story-4.11.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>system</asA>
    <iWant>to accurately aggregate ingredient quantities</iWant>
    <soThat>shopping lists show correct totals</soThat>
    <tasks>
      - Implement ingredient name normalization (AC: 1)
      - Implement same-unit quantity aggregation (AC: 2)
      - Create unit conversion table (AC: 3, 5)
      - Implement compatible unit aggregation (AC: 3)
      - Handle incompatible units (AC: 4)
      - Implement fractional quantity handling (AC: 6)
      - Implement quantity rounding (AC: 7)
      - Flag ambiguous quantities (AC: 8)
      - Create IngredientAggregationService (AC: all)
      - Add integration tests (AC: all)
    </tasks>
  </story>

  <acceptanceCriteria>
    1. System identifies duplicate ingredients by normalized name (case-insensitive, trim whitespace)
    2. Quantities with same unit added directly (2 cups + 1 cup = 3 cups)
    3. Quantities with compatible units converted then added (1 cup + 240ml = 2 cups)
    4. Incompatible units kept separate (1 whole onion + 1 cup diced onion = separate line items)
    5. Unit conversion table: cups↔ml, tablespoons↔teaspoons, lbs↔oz, grams↔kg
    6. Fractional quantities handled: 1/2 cup + 1/4 cup = 3/4 cup
    7. Aggregated quantities rounded to practical values (avoid "2.347 cups" → "2 1/3 cups")
    8. Ambiguous quantities flagged for manual review (e.g., "a pinch" + "to taste")
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc path="/home/snapiz/projects/github/timayz/imkitchen/docs/solution-architecture.md" section="11.1 Domain Crate Structure" title="Shopping Crate Architecture">
        Shopping Crate (`crates/shopping/`):
        - **Aggregate**: `ShoppingListAggregate` - Manages shopping list lifecycle, ingredient aggregation, item completion state
        - **Commands**: `GenerateShoppingList`, `MarkItemCollected`, `UpdateShoppingList`
        - **Events**: `ShoppingListGenerated`, `ItemCollected`, `ShoppingListUpdated`
        - **Business Logic**: Ingredient aggregation algorithm (sum quantities, unit conversion, deduplication)
      </doc>

      <doc path="/home/snapiz/projects/github/timayz/imkitchen/docs/tech-spec-epic-4.md" section="Ingredient Aggregation Algorithm" title="Algorithm Overview">
        Ingredient aggregation algorithm implements:
        - Ingredient normalization (lowercase, trim whitespace)
        - Unit conversion (volume: cups↔ml, weight: lbs↔oz↔g↔kg)
        - Quantity summing for compatible units
        - Separation of incompatible units (whole vs diced)
        - Algorithm complexity: O(n * m) where n = recipes, m = ingredients per recipe
      </doc>

      <doc path="/home/snapiz/projects/github/timayz/imkitchen/docs/epics.md" section="Story 4.11" title="Epic Story Definition">
        Story 4.11: Ingredient Quantity Aggregation Logic
        **Technical Notes:**
        - IngredientAggregationService domain service
        - Formula: normalize → convert → sum → round
        - Unit conversion table for volume/weight measurements
        - Fraction arithmetic library for precise calculations
        - Normalized ingredient name matching with fuzzy logic (optional enhancement)
      </doc>

      <doc path="/home/snapiz/projects/github/timayz/imkitchen/docs/solution-architecture.md" section="13.4 Best Practices - Testing" title="Testing Requirements">
        **Testing:**
        - Domain logic: Pure functions, easy to unit test
        - TDD enforced - write test first, then code
        - Coverage goal: 80% code coverage (per NFRs)
        - Unit tests: Domain aggregate logic (evento commands/events)
        - Integration tests: HTTP routes, database projections
      </doc>
    </docs>

    <code>
      <file path="/home/snapiz/projects/github/timayz/imkitchen/crates/shopping/src/aggregation.rs" kind="module" lines="1-245">
        **EXISTING IMPLEMENTATION - AC #1-5 COMPLETE**

        Current implementation handles:
        - AC #1: normalize_name() function (case-insensitive, trim whitespace) - lines 56-58
        - AC #2: Same-unit aggregation via HashMap grouping - lines 29-41
        - AC #3: Compatible unit conversion via normalize_unit() - lines 72-100
        - AC #4: Incompatible units kept separate (different base units) - lines 44-50
        - AC #5: Unit conversion table implemented - lines 76-97

        **MISSING FUNCTIONALITY - AC #6-8 (THIS STORY):**
        - AC #6: Fractional quantity handling - currently accepts f32 only, no fraction parsing/formatting
        - AC #7: Practical rounding - currently raw f32 values, no rounding to 1/4, 1/3, 1/2
        - AC #8: Ambiguous quantity detection - no flagging for "pinch", "to taste", "dash"

        **Key Functions:**
        - `aggregate(ingredients: Vec<(String, f32, String)>)` - main entry point
        - `normalize_name(name: &str)` - AC #1 implementation
        - `normalize_unit(unit: &str, quantity: f32)` - AC #3, #5 implementation

        **Test Coverage:**
        - 11 unit tests covering AC #1-5
        - Tests for name normalization, unit conversion, incompatible units
        - No tests for fractions, rounding, ambiguous quantities (AC #6-8)
      </file>

      <file path="/home/snapiz/projects/github/timayz/imkitchen/crates/shopping/src/commands.rs" kind="module" lines="TBD">
        Shopping command handlers that call IngredientAggregationService.aggregate()
        - GenerateShoppingList command
        - Uses aggregation service to combine ingredients from meal plan recipes
      </file>

      <file path="/home/snapiz/projects/github/timayz/imkitchen/crates/recipe/src/read_model.rs" kind="module" lines="TBD">
        Recipe read model queries
        - get_recipe_ingredients() function
        - Returns Vec<(name: String, quantity: f32, unit: String)>
        - Source data for aggregation
      </file>
    </code>

    <dependencies>
      <rust>
        <crate name="evento" version="1.4" features="['sqlite-migrator']">Event sourcing framework</crate>
        <crate name="sqlx" version="0.8" features="['runtime-tokio', 'sqlite', 'chrono', 'uuid']">Async database driver</crate>
        <crate name="serde" version="1.0" features="['derive']">Serialization framework</crate>
        <crate name="chrono" version="0.4" features="['serde']">Date/time library</crate>
        <crate name="thiserror" version="1.0">Error handling derive macros</crate>
        <crate name="anyhow" version="1.0">Flexible error handling</crate>

        <!-- AC #6 REQUIREMENT: Add fraction crate for fractional arithmetic -->
        <crate name="fraction" version="0.15" status="NEEDED">
          Precise fractional arithmetic for handling "1/2 cup" + "1/4 cup" = "3/4 cup"
          Required for AC #6 (fractional quantity handling)
        </crate>

        <!-- AC #6,7 CONSIDERATION: lazy_static for static conversion table -->
        <crate name="lazy_static" version="1.4" status="OPTIONAL">
          Static conversion table initialization (already using workspace HashMap, may not be needed)
        </crate>
      </rust>
    </dependencies>
  </artifacts>

  <constraints>
    **Event Sourcing Pattern:**
    - All aggregation logic must be pure functions (no database calls in domain service)
    - Shopping aggregate uses evento pattern: load → apply command → emit events
    - Read model projections update via evento subscriptions

    **Domain Service Pattern:**
    - IngredientAggregationService is stateless domain service
    - Pure functions for testability: `aggregate(Vec<Ingredient>) → Vec<AggregatedIngredient>`
    - No dependency injection needed for aggregation logic

    **Algorithm Constraints:**
    - Must handle edge cases: zero quantities, negative quantities (reject)
    - Must preserve precision for fractions (AC #6): use Fraction type, not f32
    - Rounding must be deterministic and reversible (AC #7)
    - Ambiguous quantities must not break aggregation (AC #8): flag and continue

    **Testing Requirements (TDD):**
    - Write failing tests BEFORE implementation
    - Minimum 80% code coverage (NFR requirement)
    - Unit tests for each AC (8 minimum)
    - Integration test for full aggregation flow

    **Performance Constraints:**
    - Algorithm must complete in <2 seconds for 21 meals (7 days × 3 meals)
    - Complexity: O(n * m) where n = recipes, m = ingredients per recipe
    - Hash-based grouping for O(1) lookup per ingredient
  </constraints>

  <interfaces>
    **EXISTING INTERFACE (DO NOT BREAK):**
    ```rust
    // Current signature - used by GenerateShoppingList command
    pub fn aggregate(
        ingredients: Vec<(String, f32, String)>,
    ) -> Result<Vec<(String, f32, String)>, String>
    ```

    **ENHANCED INTERFACE (AC #6-8):**
    ```rust
    // Proposed signature with fractional support
    pub struct Ingredient {
        pub name: String,
        pub quantity: Fraction,  // Changed from f32 to support AC #6
        pub unit: String,
    }

    pub struct AggregatedIngredient {
        pub name: String,
        pub quantity: Fraction,  // AC #6: fractional quantities
        pub formatted_quantity: String,  // AC #7: rounded to practical values
        pub unit: String,
        pub is_ambiguous: bool,  // AC #8: flagged for manual review
    }

    pub fn aggregate_enhanced(
        ingredients: Vec<Ingredient>,
    ) -> Result<Vec<AggregatedIngredient>, String>
    ```

    **BACKWARDS COMPATIBILITY STRATEGY:**
    - Option 1: Create `aggregate_enhanced()` alongside existing `aggregate()`
    - Option 2: Update `aggregate()` signature with conversion adapters
    - Recommendation: Option 1 (phased migration, less risk)

    **INTEGRATION WITH COMMANDS:**
    ```rust
    // crates/shopping/src/commands.rs
    pub async fn generate_shopping_list(
        cmd: GenerateShoppingListCommand,
        executor: &impl Executor,
    ) -> Result<String, ShoppingError> {
        // 1. Query meal plan recipes
        let recipes = meal_planning::read_model::get_meal_plan_recipes(cmd.meal_plan_id, executor).await?;

        // 2. Extract ingredients
        let ingredients = recipes.iter()
            .flat_map(|recipe| recipe.ingredients.clone())
            .map(|ing| Ingredient {
                name: ing.name,
                quantity: Fraction::from_str(&ing.quantity)?,  // AC #6: parse fractions
                unit: ing.unit,
            })
            .collect();

        // 3. Aggregate (NEW enhanced version)
        let aggregated = IngredientAggregationService::aggregate_enhanced(ingredients)?;

        // 4. Save to database
        // ... emit ShoppingListGenerated event
    }
    ```
  </interfaces>

  <tests>
    <standards>
      **Testing Framework:**
      - Unit tests: Rust `#[test]` with `cargo test`
      - Integration tests: `tests/*.rs` files with tokio::test
      - Coverage: `cargo tarpaulin --out Xml` (target 80%+)

      **TDD Workflow (MANDATORY):**
      1. Write failing test for AC (e.g., test_fraction_addition_AC6)
      2. Run `cargo test` - verify test fails (RED)
      3. Implement minimum code to pass test
      4. Run `cargo test` - verify test passes (GREEN)
      5. Refactor code, maintain passing tests
      6. Repeat for next AC

      **Test Organization:**
      - Unit tests: `#[cfg(test)] mod tests` in `aggregation.rs`
      - Integration tests: `tests/ingredient_aggregation_tests.rs` (new file)
    </standards>

    <locations>
      **Unit Tests:**
      - `/home/snapiz/projects/github/timayz/imkitchen/crates/shopping/src/aggregation.rs` (lines 103-244)
      - Existing tests cover AC #1-5 (11 tests)
      - Add tests for AC #6-8 in same module

      **Integration Tests:**
      - `/home/snapiz/projects/github/timayz/imkitchen/tests/ingredient_aggregation_tests.rs` (NEW FILE)
      - Full aggregation flow test with fractions, rounding, ambiguous quantities
      - Multiple recipes with overlapping ingredients

      **Test Utilities:**
      - Helper function: `parse_quantity(str) → Fraction` (for test data setup)
      - Helper function: `format_quantity(Fraction) → String` (for assertion formatting)
    </locations>

    <ideas>
      **AC #1 (Name Normalization) - EXISTING:**
      - test_normalize_ingredient_name_case_insensitive() ✅
      - test_normalize_ingredient_name_trim_whitespace() ✅

      **AC #2 (Same-Unit Aggregation) - EXISTING:**
      - test_aggregate_same_ingredient_same_unit() ✅

      **AC #3 (Compatible Unit Conversion) - EXISTING:**
      - test_aggregate_unit_conversion() ✅

      **AC #4 (Incompatible Units Separate) - EXISTING:**
      - test_aggregate_incompatible_units_kept_separate() ✅

      **AC #5 (Unit Conversion Table) - EXISTING:**
      - test_normalize_unit_volume() ✅
      - test_normalize_unit_weight() ✅
      - test_normalize_unit_count() ✅

      **AC #6 (Fractional Quantities) - NEW TESTS NEEDED:**
      - test_parse_fraction_pure_fraction() - "1/2" → Fraction(1, 2)
      - test_parse_fraction_mixed_fraction() - "1 1/2" → Fraction(3, 2)
      - test_parse_fraction_decimal() - "0.5" → Fraction(1, 2)
      - test_parse_fraction_whole_number() - "2" → Fraction(2, 1)
      - test_format_fraction_simplify() - Fraction(4, 8) → "1/2"
      - test_format_fraction_mixed() - Fraction(3, 2) → "1 1/2"
      - test_aggregate_fractions_addition() - "1/2 cup" + "1/4 cup" = "3/4 cup"

      **AC #7 (Practical Rounding) - NEW TESTS NEEDED:**
      - test_round_to_quarter_small_quantities() - 0.23 → 1/4
      - test_round_to_third_small_quantities() - 0.34 → 1/3
      - test_round_to_half_medium_quantities() - 1.7 → 1 1/2
      - test_round_to_whole_large_quantities() - 10.3 → 10
      - test_round_avoid_excessive_precision() - 2.347 → "2 1/3"

      **AC #8 (Ambiguous Quantities) - NEW TESTS NEEDED:**
      - test_detect_ambiguous_pinch() - "a pinch" → is_ambiguous = true
      - test_detect_ambiguous_to_taste() - "to taste" → is_ambiguous = true
      - test_detect_ambiguous_dash() - "dash" → is_ambiguous = true
      - test_non_ambiguous_quantities() - "2 cups" → is_ambiguous = false
      - test_aggregate_ambiguous_flagged() - Verify ambiguous items have is_ambiguous flag

      **Integration Test (All ACs):**
      - test_full_aggregation_flow_with_enhancements()
        - 3 recipes with overlapping ingredients
        - Fractional quantities ("1/2 cup", "1 1/4 cups")
        - Ambiguous quantities ("to taste")
        - Verify fractions aggregated correctly
        - Verify practical rounding applied
        - Verify ambiguous items flagged
    </ideas>
  </tests>
</story-context>
