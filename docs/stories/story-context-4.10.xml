<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>4</epicId>
    <storyId>4.10</storyId>
    <title>Push Notification Permission Flow</title>
    <status>Draft</status>
    <generatedAt>2025-10-18</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>/home/snapiz/projects/github/timayz/imkitchen/docs/stories/story-4.10.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>user</asA>
    <iWant>to enable push notifications for reminders</iWant>
    <soThat>I receive timely preparation alerts</soThat>
    <tasks>
      - Implement notification permission request flow (AC: 1, 2, 3)
      - Implement service worker registration (AC: 4)
      - Implement fallback for denied permissions (AC: 5, 6)
      - Add notification status to settings page (AC: 7)
      - Implement grace period for re-prompting (AC: 8)
      - Create push subscription endpoints (AC: 4)
      - Add push subscription database schema (AC: 4)
      - Update onboarding flow UI (AC: 1, 2, 3)
      - Add integration tests (AC: all)
      - Service worker notification handling (AC: 4)
    </tasks>
  </story>

  <acceptanceCriteria>
    1. Onboarding includes notification permission prompt
    2. Prompt explains benefits: "Get reminders for advance prep and cooking times"
    3. User can allow, deny, or skip
    4. If allowed, register service worker and subscription
    5. If denied, fall back to in-app notifications only
    6. User can change permission in browser settings
    7. Settings page shows current notification status
    8. Grace period: don't re-prompt if user denied within last 30 days
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc path="docs/tech-spec-epic-4.md" title="Epic 4 Technical Specification" section="Notifications Crate Architecture">
        Push Notification Implementation Details:
        - Web Push API Integration (RFC 8030, VAPID authentication)
        - Subscription storage in push_subscriptions table
        - VAPID keys required for push subscription (generate once, store in config)
        - Subscription endpoint URL unique per browser/device
        - Encryption keys (p256dh, auth) required for secure push delivery
        - Background worker polls for due notifications and sends via Web Push API
        - Notification payload format: title, body, icon, badge, actions, data
      </doc>
      <doc path="docs/solution-architecture.md" title="Solution Architecture" section="9.3 Push Notifications">
        Web Push API (browser standard, no vendor):
        - User enables notifications in /profile settings
        - Browser requests notification permission
        - Service worker registered (/sw.js)
        - PushManager.subscribe() creates subscription with VAPID public key
        - Subscription data (endpoint, p256dh_key, auth_key) sent to server
        - Server uses web-push crate to send notifications via VAPID
        - Notification payload: Title, body, icon, action buttons
        - Service worker handles push event and notification clicks
      </doc>
      <doc path="docs/solution-architecture.md" title="Solution Architecture" section="Technology Stack">
        Dependencies:
        - web-push 0.10+ for VAPID-based push notifications (browser standard)
        - Service Worker (Workbox 7.1+) for PWA offline caching
        - evento 1.4+ for event sourcing with SQLite backend
        - SQLite for embedded database (event store + read models)
      </doc>
      <doc path="docs/epics.md" title="Epic Breakdown" section="Story 4.10: Push Notification Permission Flow">
        User Story: As a user, I want to enable push notifications for reminders, so that I receive timely preparation alerts.
        8 Acceptance Criteria covering permission request, service worker registration, fallback, settings page, and grace period.
      </doc>
      <doc path="docs/stories/story-1.4.md" title="User Profile Creation (Onboarding)" section="Onboarding Wizard">
        Prerequisite story establishing onboarding wizard flow:
        - 4-step wizard: dietary restrictions, household size, skill level, availability
        - Currently in templates/pages/onboarding.html
        - TwinSpark for inline form submission without page reload
        - Story 4.10 adds notification permission as optional step 5
      </doc>
    </docs>
    <code>
      <file path="crates/notifications/src/commands.rs" kind="command-handler" symbol="subscribe_to_push" lines="253-322" reason="Existing subscribe_to_push command handler - validates endpoint, keys, creates PushSubscriptionCreated event"/>
      <file path="crates/notifications/src/commands.rs" kind="command-struct" symbol="SubscribeToPushCommand" lines="49-56" reason="Command structure for push subscription - user_id, endpoint, p256dh_key, auth_key"/>
      <file path="crates/notifications/src/events.rs" kind="event" symbol="PushSubscriptionCreated" lines="62-73" reason="Event emitted when user subscribes to push - subscription_id, user_id, endpoint, keys, created_at"/>
      <file path="crates/notifications/src/aggregate.rs" kind="aggregate" symbol="PushSubscriptionAggregate" lines="38-50" reason="Separate aggregate for push subscriptions - tracks subscription lifecycle"/>
      <file path="crates/notifications/src/read_model.rs" kind="projection" symbol="project_push_subscription_created" lines="203-239" reason="Projection handler for PushSubscriptionCreated - inserts into push_subscriptions table"/>
      <file path="crates/notifications/src/read_model.rs" kind="query" symbol="get_push_subscription_by_user" lines="264-285" reason="Query to fetch user's push subscription - returns latest subscription by created_at"/>
      <file path="crates/notifications/src/push.rs" kind="module" symbol="send_push_notification" lines="123-231" reason="Web Push API integration - sends notification using web-push crate with VAPID signature"/>
      <file path="src/routes/notifications.rs" kind="route-handler" symbol="subscribe_push" lines="179-210" reason="Existing POST /api/notifications/subscribe endpoint - calls subscribe_to_push command"/>
      <file path="src/routes/profile.rs" kind="route-handler" symbol="get_onboarding" lines="84-100" reason="Onboarding wizard handler - pattern for adding notification permission step"/>
      <file path="templates/pages/onboarding.html" kind="template" lines="1-246" reason="Onboarding wizard template with 4 steps - needs step 5 for notification permission prompt"/>
      <file path="static/sw.js" kind="service-worker" symbol="push event handler" lines="18-58" reason="Service worker push event handler - displays notifications, parses payload"/>
      <file path="migrations/05_push_subscriptions.sql" kind="migration" reason="Existing push_subscriptions table schema - id, user_id, endpoint, p256dh_key, auth_key, created_at"/>
      <file path="migrations/00_v0.1.sql" kind="migration" reason="Users table schema - needs notification_permission_status and last_permission_denial_at columns"/>
    </code>
    <dependencies>
      <rust>
        <package name="evento" version="1.4" reason="Event sourcing framework - aggregate pattern, event handlers, subscriptions"/>
        <package name="sqlx" version="0.8" reason="Async SQL queries for read model projections"/>
        <package name="axum" version="0.8" reason="HTTP server and routing"/>
        <package name="askama" version="0.14" reason="Type-safe server-side templates"/>
        <package name="web-push" version="0.10" reason="VAPID-based Web Push API for browser-native push notifications"/>
        <package name="chrono" version="0.4" reason="Date/time handling for grace period tracking"/>
        <package name="uuid" version="1.10" reason="Subscription ID generation"/>
        <package name="thiserror" version="1.0" reason="Custom error types"/>
        <package name="tokio" version="1.40" reason="Async runtime"/>
        <package name="serde" version="1.0" reason="JSON serialization for API responses"/>
        <package name="serde_json" version="1.0" reason="JSON parsing for push payloads"/>
        <package name="base64" version="latest" reason="Base64 validation for p256dh_key and auth_key"/>
        <package name="url" version="latest" reason="URL validation for push endpoints"/>
      </rust>
    </dependencies>
  </artifacts>

  <constraints>
    - Event sourcing pattern: All state changes must emit events (PushSubscriptionCreated, NotificationPermissionChanged)
    - CQRS: Commands write events, queries read from read models
    - TDD enforced: Write failing tests first, then implement
    - 80% code coverage target via cargo-tarpaulin
    - Use evento-generated ULID as subscription_id for aggregate lookup consistency
    - Authorization: Validate user owns subscription before deletion (prevent ID enumeration)
    - Security: HTTPS-only endpoints, validate base64 keys, prevent timing side-channels
    - Naming: Commands use PascalCase imperative, Events use PascalCase past tense
    - Database: SQLite with evento event store + read model tables
    - Template integration: Use TwinSpark for inline permission request without full page reload
    - Web Push API: RFC 8030 compliance, VAPID authentication, browser-native (no vendor lock-in)
    - Onboarding: Make notification permission OPTIONAL - can skip and enable later in settings
    - Grace period: Track denial timestamp, prevent re-prompt within 30 days, allow manual retry in settings
    - Browser compatibility: Chrome 50+, Firefox 44+, Edge 17+, Safari 16+ (iOS 16.4+)
  </constraints>

  <interfaces>
    <api name="POST /api/push/subscribe" kind="http-endpoint" signature="async fn subscribe_push(Extension(auth): Extension&lt;Auth&gt;, State(state): State&lt;AppState&gt;, Json(body): Json&lt;PushSubscriptionBody&gt;) -&gt; Result&lt;impl IntoResponse, AppError&gt;" path="src/routes/push.rs" reason="New endpoint to create - stores push subscription and emits PushSubscriptionCreated event"/>
    <api name="DELETE /api/push/unsubscribe" kind="http-endpoint" signature="async fn unsubscribe_push(Extension(auth): Extension&lt;Auth&gt;, State(state): State&lt;AppState&gt;, Path(subscription_id): Path&lt;String&gt;) -&gt; Result&lt;impl IntoResponse, AppError&gt;" path="src/routes/push.rs" reason="New endpoint to create - removes push subscription with ownership validation"/>
    <api name="GET /api/push/status" kind="http-endpoint" signature="async fn get_push_status(Extension(auth): Extension&lt;Auth&gt;, State(state): State&lt;AppState&gt;) -&gt; Result&lt;impl IntoResponse, AppError&gt;" path="src/routes/push.rs" reason="New endpoint to create - checks if user has active subscription, returns enabled/disabled status"/>
    <api name="POST /api/push/permission-denied" kind="http-endpoint" signature="async fn record_permission_denial(Extension(auth): Extension&lt;Auth&gt;, State(state): State&lt;AppState&gt;) -&gt; Result&lt;impl IntoResponse, AppError&gt;" path="src/routes/push.rs" reason="New endpoint to create - stores denial timestamp for grace period tracking"/>
    <api name="Notification.requestPermission()" kind="browser-api" signature="static Promise&lt;NotificationPermission&gt; requestPermission()" path="static/js/push-subscription.js" reason="Browser API call to request notification permission - returns 'granted', 'denied', or 'default'"/>
    <api name="navigator.serviceWorker.register()" kind="browser-api" signature="Promise&lt;ServiceWorkerRegistration&gt; register(scriptURL)" path="static/js/push-subscription.js" reason="Browser API to register service worker (/sw.js)"/>
    <api name="PushManager.subscribe()" kind="browser-api" signature="Promise&lt;PushSubscription&gt; subscribe(options)" path="static/js/push-subscription.js" reason="Browser API to create push subscription with VAPID public key"/>
  </interfaces>

  <tests>
    <standards>
      TDD approach mandatory: Write failing test first, implement feature to pass test.
      Test pyramid: Unit tests (domain logic), Integration tests (HTTP + database), E2E tests (Playwright).
      Use tokio::test for async tests, evento::unsafe_oneshot for synchronous event processing in tests.
      Target 80% code coverage via cargo-tarpaulin.
      Test file naming: *_tests.rs or *_integration_tests.rs
      Given-When-Then structure in test comments for clarity.
      Security testing: Verify permission checks, prevent ID enumeration via timing side-channel.
    </standards>
    <locations>
      - tests/push_notification_permission_tests.rs (new file to create)
      - crates/notifications/src/commands.rs (unit tests inline)
      - src/routes/push.rs (integration tests for new endpoints)
      - static/js/push-subscription.js (client-side logic - E2E tests via Playwright)
    </locations>
    <ideas>
      - AC #1,2,3: Test onboarding step 5 displays permission prompt with benefit explanation and Allow/Skip buttons
      - AC #4: Test allow permission creates push subscription (POST /api/push/subscribe with valid subscription data)
      - AC #4: Test PushSubscriptionCreated event emitted, row in push_subscriptions table
      - AC #4: Test service worker registered and push subscription created via PushManager API
      - AC #5: Test denied permission stores status='denied' in user preferences
      - AC #5: Test denied permission stores last_permission_denial_at timestamp
      - AC #6: Test settings page provides browser-specific instructions for changing permission
      - AC #7: Test settings page displays "Notifications Enabled (2 devices)" when subscriptions exist
      - AC #7: Test settings page displays "Notifications Disabled" when no subscriptions
      - AC #8: Test grace period prevents re-prompting before 30 days elapsed
      - AC #8: Test manual "Try Again" button in settings bypasses grace period
      - AC #8: Test grace period reset after user manually re-enables
      - Negative test: User cannot delete another user's subscription (returns PermissionDenied)
      - Negative test: Invalid endpoint URL (non-HTTPS) rejected with error
      - Negative test: Invalid base64 keys rejected with error
      - Edge case: Multiple devices can subscribe (unique endpoint constraint)
      - Edge case: Duplicate subscription request is idempotent (upsert by endpoint)
      - Security test: Endpoint validation prevents SSRF attacks (validate URL format)
    </ideas>
  </tests>
</story-context>
