<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>3</epicId>
    <storyId>3.12</storyId>
    <title>Recipe Complexity Calculation</title>
    <status>Draft</status>
    <generatedAt>2025-10-17</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>/home/snapiz/projects/github/timayz/imkitchen/docs/stories/story-3.12.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>system</asA>
    <iWant>to accurately calculate recipe complexity</iWant>
    <soThat>meal assignments match user capacity and availability</soThat>
    <tasks>
      - Task 1: Implement RecipeComplexityCalculator domain service (AC: #1, #2, #3, #4, #5)
      - Task 2: Integrate complexity calculation into recipe creation flow (AC: #1, #6)
      - Task 3: Add complexity recalculation on recipe updates (AC: #7)
      - Task 4: Add complexity column to recipes read model (AC: #6)
      - Task 5: Display complexity on recipe cards and detail pages (AC: #8)
      - Task 6: Add complexity filtering to recipe library (AC: #8)
      - Task 7: Integration with meal planning algorithm (AC: #3, #4, #5)
      - Task 8: Comprehensive testing (AC: #1-#8)
    </tasks>
  </story>

  <acceptanceCriteria>
    1. Complexity calculated automatically on recipe creation/update
    2. Scoring factors: ingredient count (weight 30%), instruction step count (weight 40%), advance prep requirement (weight 30%)
    3. Simple: &lt;8 ingredients, &lt;6 steps, no advance prep (score &lt;30)
    4. Moderate: 8-15 ingredients OR 6-10 steps (score 30-60)
    5. Complex: &gt;15 ingredients OR &gt;10 steps OR advance prep required (score &gt;60)
    6. Complexity badge stored in recipe read model for fast filtering
    7. Recalculated automatically when recipe edited
    8. Complexity visible on recipe cards throughout app
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/tech-spec-epic-3.md</path>
        <title>Technical Specification: Intelligent Meal Planning Engine</title>
        <section>Services and Modules - RecipeComplexityCalculator</section>
        <snippet>
          Lines 170-231: Complete RecipeComplexityCalculator implementation specification with formula, scoring logic, and enum definition.
          Formula: complexity_score = (ingredients * 0.3) + (steps * 0.4) + (advance_prep_multiplier * 0.3)
          - Simple: score &lt; 30, Moderate: 30-60, Complex: &gt; 60
          - advance_prep_multiplier: 0 (no prep), 50 (&lt;4 hours), 100 (>=4 hours)
        </snippet>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-3.md</path>
        <title>Technical Specification: Intelligent Meal Planning Engine</title>
        <section>Services and Modules - MealPlanningAlgorithm</section>
        <snippet>
          Lines 70-168: MealPlanningAlgorithm uses complexity scores in constraint satisfaction.
          score_recipe_for_slot() uses complexity_fit, time_fit, and freshness_fit with weighted scoring.
          Complexity Constraint (lines 106-110): Match recipe difficulty to user skill level and day energy.
        </snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic Breakdown</title>
        <section>Story 3.12: Recipe Complexity Calculation</section>
        <snippet>
          Lines 824-846: Acceptance criteria and formula definition for complexity calculation.
          Technical notes specify RecipeComplexityCalculator as domain service with formula details.
        </snippet>
      </doc>
      <doc>
        <path>docs/solution-architecture.md</path>
        <title>Solution Architecture Document</title>
        <section>Event Sourcing and CQRS</section>
        <snippet>
          Section 2.1: Event-sourced DDD architecture with domain services in domain crates.
          Section 3.2: Read models as CQRS projections from event stream.
          Section 11.1: Domain crate structure with domain services as pure functions.
        </snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>crates/recipe/src/tagging.rs</path>
        <kind>domain_service</kind>
        <symbol>RecipeComplexityCalculator</symbol>
        <lines>42-86</lines>
        <reason>**ALREADY IMPLEMENTED**: RecipeComplexityCalculator domain service exists with complete formula implementation matching spec. Calculate method takes ingredients, instructions, advance_prep_hours and returns Complexity enum. Formula: (ingredients * 0.3) + (steps * 0.4) + (advance_prep_multiplier * 0.3) with thresholds: Simple &lt;30, Moderate 30-60, Complex &gt;60.</reason>
      </artifact>
      <artifact>
        <path>crates/recipe/src/tagging.rs</path>
        <kind>domain_model</kind>
        <symbol>Complexity</symbol>
        <lines>15-32</lines>
        <reason>Complexity enum (Simple, Moderate, Complex) with as_str() method for database serialization. Already implemented and used in aggregate.</reason>
      </artifact>
      <artifact>
        <path>crates/recipe/src/tagging.rs</path>
        <kind>domain_model</kind>
        <symbol>RecipeTags</symbol>
        <lines>34-40</lines>
        <reason>RecipeTags struct contains complexity field (Option&lt;Complexity&gt;), cuisine, and dietary_tags. Used in Recipe aggregate state.</reason>
      </artifact>
      <artifact>
        <path>crates/recipe/src/commands.rs</path>
        <kind>command_handler</kind>
        <symbol>tag_recipe_command</symbol>
        <lines>155-178</lines>
        <reason>**ALREADY INTEGRATED**: tag_recipe_command already calls RecipeComplexityCalculator::calculate() and emits RecipeTagged event with complexity. Automatic tagging happens after RecipeCreated event.</reason>
      </artifact>
      <artifact>
        <path>crates/recipe/src/events.rs</path>
        <kind>event</kind>
        <symbol>RecipeTagged</symbol>
        <lines>86-94</lines>
        <reason>RecipeTagged event stores complexity (as string), cuisine, and dietary_tags. Emitted after recipe creation/update for automatic tagging.</reason>
      </artifact>
      <artifact>
        <path>crates/recipe/src/aggregate.rs</path>
        <kind>event_handler</kind>
        <symbol>recipe_tagged</symbol>
        <lines>147-166</lines>
        <reason>recipe_tagged event handler updates aggregate tags.complexity by parsing string to Complexity enum.</reason>
      </artifact>
      <artifact>
        <path>crates/recipe/src/read_model.rs</path>
        <kind>projection</kind>
        <symbol>recipe_tagged_handler</symbol>
        <lines>273-281</lines>
        <reason>**ALREADY INTEGRATED**: Projection handler updates recipes.complexity column from RecipeTagged event. SQL: UPDATE recipes SET complexity = ?1, cuisine = ?2, dietary_tags = ?3 WHERE id = ?4</reason>
      </artifact>
      <artifact>
        <path>crates/recipe/src/read_model.rs</path>
        <kind>model</kind>
        <symbol>RecipeView</symbol>
        <lines>20-36</lines>
        <reason>RecipeView read model struct includes complexity: Option&lt;String&gt; field for queries. Already part of schema.</reason>
      </artifact>
      <artifact>
        <path>crates/recipe/src/tagging.rs</path>
        <kind>test</kind>
        <symbol>test_complexity_simple, test_complexity_moderate, test_complexity_complex_with_advance_prep</symbol>
        <lines>332-390</lines>
        <reason>**TESTS EXIST**: Three unit tests for complexity calculation covering Simple, Moderate, and Complex (with advance prep) scenarios.</reason>
      </artifact>
      <artifact>
        <path>crates/meal_planning/src/algorithm.rs</path>
        <kind>algorithm</kind>
        <symbol>MealPlanningAlgorithm</symbol>
        <lines>TBD</lines>
        <reason>MealPlanningAlgorithm should use recipe.complexity from RecipeView for constraint satisfaction. Need to verify integration point.</reason>
      </artifact>
    </code>
    <dependencies>
      <rust>
        <package name="evento" version="1.4" features="sqlite-migrator" />
        <package name="sqlx" version="0.8" features="runtime-tokio, sqlite, chrono, uuid" />
        <package name="serde" version="1.0" features="derive" />
        <package name="bincode" version="2.0" />
        <package name="chrono" version="0.4" features="serde" />
        <package name="anyhow" version="1.0" />
        <package name="thiserror" version="1.0" />
      </rust>
    </dependencies>
  </artifacts>

  <constraints>
    1. **Domain Service Pattern**: RecipeComplexityCalculator is a stateless domain service (pure function). No database access, no side effects.
    2. **Event Sourcing**: Complexity calculation results captured in RecipeTagged event for audit trail.
    3. **CQRS Projection**: Complexity stored in recipes.complexity column (read model) for fast filtering.
    4. **Automatic Calculation**: Complexity calculated on every RecipeCreated and RecipeUpdated event via tag_recipe_command.
    5. **Database Schema**: complexity column in recipes table stores string ("simple", "moderate", "complex") with index.
    6. **TDD Required**: 80% code coverage target. Write tests first (red), implement (green), refactor.
    7. **NO BREAKING CHANGES**: RecipeComplexityCalculator, Complexity enum, RecipeTags, and RecipeTagged event ALREADY EXIST. Do not recreate or modify core logic.
  </constraints>

  <interfaces>
    <interface>
      <name>RecipeComplexityCalculator::calculate</name>
      <kind>domain_service</kind>
      <signature>pub fn calculate(ingredients: &amp;[Ingredient], instructions: &amp;[InstructionStep], advance_prep_hours: Option&lt;u32&gt;) -&gt; Complexity</signature>
      <path>crates/recipe/src/tagging.rs:60-86</path>
      <usage>**ALREADY CALLED** by tag_recipe_command (commands.rs:158). No integration work needed for creation flow.</usage>
    </interface>
    <interface>
      <name>tag_recipe_command</name>
      <kind>command_handler</kind>
      <signature>pub async fn tag_recipe_command(executor: &amp;impl evento::Executor, command: TagRecipeCommand) -&gt; Result&lt;(), RecipeError&gt;</signature>
      <path>crates/recipe/src/commands.rs:126-178</path>
      <usage>**ALREADY INTEGRATED**: Automatically called after RecipeCreated. Calls RecipeComplexityCalculator and emits RecipeTagged event.</usage>
    </interface>
    <interface>
      <name>recipe_tagged_handler (projection)</name>
      <kind>event_handler</kind>
      <signature>pub async fn recipe_tagged_handler(context: &amp;evento::Context&lt;'_, E&gt;, event: evento::EventDetails&lt;RecipeTagged&gt;) -&gt; anyhow::Result&lt;()&gt;</signature>
      <path>crates/recipe/src/read_model.rs:260-282</path>
      <usage>**ALREADY REGISTERED**: Projection handler updates recipes.complexity from RecipeTagged event. No work needed.</usage>
    </interface>
    <interface>
      <name>get_recipes_by_user (query)</name>
      <kind>query</kind>
      <signature>pub async fn get_recipes_by_user(user_id: &amp;str, pool: &amp;sqlx::SqlitePool) -&gt; Result&lt;Vec&lt;RecipeView&gt;, RecipeError&gt;</signature>
      <path>crates/recipe/src/read_model.rs:335-377</path>
      <usage>Query returns RecipeView with complexity field. Use for recipe library display with complexity filtering.</usage>
    </interface>
  </interfaces>

  <tests>
    <standards>
      TDD enforced per solution-architecture.md section 15:
      - **Unit tests**: Domain logic in crates/recipe/tests/ (complexity calculation formula)
      - **Integration tests**: HTTP routes and projections in tests/recipe_tests.rs
      - **E2E tests**: Full user flows with Playwright in e2e/tests/recipe-management.spec.ts
      - **Coverage target**: 80% via cargo tarpaulin
      - **Test-first approach**: Write test (red) → Implement (green) → Refactor
      - **Frameworks**: Rust cargo test, Playwright for E2E
    </standards>
    <locations>
      - crates/recipe/tests/recipe_tests.rs (unit tests for complexity logic)
      - tests/recipe_integration_tests.rs (integration tests for routes)
      - e2e/tests/recipe-management.spec.ts (E2E tests for UI)
    </locations>
    <ideas>
      **CRITICAL FINDING**: Story 3.12 appears to be MOSTLY COMPLETE. RecipeComplexityCalculator, automatic tagging, and projection handlers already exist and are integrated. Remaining work:

      AC #6: **Database Migration** - Add complexity column to recipes table (may already exist, need to verify migration 002_create_recipes_table.sql)
      AC #8: **UI Display** - Add complexity badges to recipe cards (templates/components/recipe-card.html) and detail pages
      AC #8: **Filtering** - Add complexity filter to recipe library page (may need new query parameter)
      AC #7: **Recalculation** - Verify complexity recalculates on RecipeUpdated (likely already works via tag_recipe_command)

      **Test Ideas Mapped to ACs**:
      1. AC #1: **TESTS EXIST** (tagging.rs:332-390) - Verify existing tests cover simple, moderate, complex cases
      2. AC #2: **TESTS EXIST** - Formula weights already tested (30%, 40%, 30%)
      3. AC #3: **TESTS EXIST** - test_complexity_simple validates &lt;30 score
      4. AC #4: **TESTS EXIST** - test_complexity_moderate validates 30-60 score
      5. AC #5: **TESTS EXIST** - test_complexity_complex_with_advance_prep validates &gt;60 score
      6. AC #6: Test database migration creates complexity column with index
      7. AC #7: Test recipe update triggers recalculation (integration test)
      8. AC #8: E2E test - create recipe, verify badge on card, filter by complexity

      **Recommended Approach**:
      1. Audit existing code to confirm what's implemented
      2. Check database schema for complexity column (migrations/002_create_recipes_table.sql)
      3. If column missing, add migration
      4. Add complexity badges to templates (UI work)
      5. Add complexity filtering to recipe library (query + UI)
      6. Write integration tests for recalculation on update
      7. Write E2E tests for UI visibility
    </ideas>
  </tests>
</story-context>
