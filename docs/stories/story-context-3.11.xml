<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>3</epicId>
    <storyId>11</storyId>
    <title>Meal Plan Persistence and Activation</title>
    <status>Draft</status>
    <generatedAt>2025-10-17</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>/home/snapiz/projects/github/timayz/imkitchen/docs/stories/story-3.11.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>user</asA>
    <iWant>my meal plan to persist across sessions</iWant>
    <soThat>I don't lose my schedule when I close the browser or switch devices</soThat>
    <tasks>
      <task id="1">Implement meal plan persistence in read model projection</task>
      <task id="2">Enforce single active meal plan constraint</task>
      <task id="3">Implement active meal plan query for dashboard/calendar</task>
      <task id="4">Update dashboard route to load and display active meal plan</task>
      <task id="5">Update calendar route to load and display active meal plan</task>
      <task id="6">Implement meal plan archival on regeneration</task>
      <task id="7">Implement stable meal plan ID during replacements</task>
      <task id="8">Add comprehensive integration tests for persistence</task>
      <task id="9">Update error handling for missing active meal plan</task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="1">Generated meal plan stored in database immediately upon generation</criterion>
    <criterion id="2">Exactly one meal plan active per user at a time (enforced by database constraint)</criterion>
    <criterion id="3">Active meal plan automatically loaded and displayed on dashboard and calendar views</criterion>
    <criterion id="4">Meal plan persists across browser sessions and device switches (server-side storage)</criterion>
    <criterion id="5">Regenerating meal plan archives the old plan (sets is_active=false) and creates new active plan (is_active=true)</criterion>
    <criterion id="6">Active plan indicated by is_active boolean flag in database</criterion>
    <criterion id="7">Historical meal plans preserved in database for audit trail (event sourcing maintains full history)</criterion>
    <criterion id="8">User can access meal plan from any authenticated session without re-generation</criterion>
    <criterion id="9">Meal plan ID remains stable during replacements (only regeneration creates new plan ID)</criterion>
    <criterion id="10">Database enforces unique constraint: only one is_active=true meal plan per user</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>/home/snapiz/projects/github/timayz/imkitchen/docs/tech-spec-epic-3.md</path>
        <title>Technical Specification: Intelligent Meal Planning Engine</title>
        <section>Data Models and Contracts</section>
        <snippet>Defines meal_plans and meal_assignments read model schema with status field ('active' or 'archived'), rotation_state JSON field, and foreign key constraints. Includes evento subscription handlers for projecting events to read models with idempotency and transaction handling.</snippet>
      </doc>
      <doc>
        <path>/home/snapiz/projects/github/timayz/imkitchen/docs/tech-spec-epic-3.md</path>
        <title>Technical Specification: Intelligent Meal Planning Engine</title>
        <section>Read Model Projections</section>
        <snippet>Documents meal_plan_generated_handler projection logic: deactivate existing active plans, insert new meal plan with status='active', insert meal assignments, all within a transaction for atomicity.</snippet>
      </doc>
      <doc>
        <path>/home/snapiz/projects/github/timayz/imkitchen/docs/solution-architecture.md</path>
        <title>Solution Architecture Document</title>
        <section>2.1 Architecture Pattern: Event-Sourced Monolith</section>
        <snippet>Event-sourced monolithic application with DDD bounded contexts. Commands write events to evento event store, queries read from materialized view tables (CQRS pattern). All state changes recorded as immutable events.</snippet>
      </doc>
      <doc>
        <path>/home/snapiz/projects/github/timayz/imkitchen/docs/solution-architecture.md</path>
        <title>Solution Architecture Document</title>
        <section>3.2 Data Models and Relationships - meal_plans table</section>
        <snippet>meal_plans table schema: id (PK), user_id (FK), start_date, status ('active' or 'archived'), rotation_state (JSON), created_at. Unique constraint on (user_id, is_active) ensures only one active plan per user. Foreign key to users with ON DELETE CASCADE.</snippet>
      </doc>
      <doc>
        <path>/home/snapiz/projects/github/timayz/imkitchen/docs/epics.md</path>
        <title>Epic Breakdown</title>
        <section>Story 3.11: Meal Plan Persistence and Activation</section>
        <snippet>Acceptance criteria: Generated meal plan stored in database, exactly one active per user, persists across sessions/devices, regeneration archives old plan, active flag in database, historical plans preserved, stable meal plan ID during replacements.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/read_model.rs</path>
        <kind>module</kind>
        <symbol>MealPlanQueries::get_active_meal_plan</symbol>
        <lines>54-71</lines>
        <reason>CRITICAL: Existing query function to retrieve active meal plan for user. Returns Option&lt;MealPlanReadModel&gt; by querying meal_plans WHERE status='active'. This is the core function dashboard and calendar routes must use.</reason>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/read_model.rs</path>
        <kind>module</kind>
        <symbol>MealPlanQueries::get_active_meal_plan_with_assignments</symbol>
        <lines>108-125</lines>
        <reason>Convenience query that fetches active meal plan with all meal assignments joined. Returns Option&lt;MealPlanWithAssignments&gt; for template rendering.</reason>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/read_model.rs</path>
        <kind>module</kind>
        <symbol>meal_plan_generated_handler</symbol>
        <lines>390-463</lines>
        <reason>CRITICAL: Evento subscription handler that projects MealPlanGenerated events to read models. Includes idempotency check (line 399), transaction handling (line 410), archival of existing active plans (line 413-422), and atomic insert of meal plan + assignments. Story 3.11 must verify this handler correctly enforces single active plan constraint.</reason>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/read_model.rs</path>
        <kind>module</kind>
        <symbol>meal_plan_regenerated_handler</symbol>
        <lines>647-706</lines>
        <reason>Handler for MealPlanRegenerated events. Deletes old meal_assignments, inserts new ones, updates rotation_state - all in a transaction. Note: Does NOT create new meal plan row, reuses existing meal_plan_id (stable ID per AC-9).</reason>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/aggregate.rs</path>
        <kind>module</kind>
        <symbol>MealPlanAggregate</symbol>
        <lines>16-33</lines>
        <reason>Aggregate root for meal plans with status field ('active' or 'archived'). Rebuilt from events via evento. Contains meal_plan_id, user_id, start_date, status, rotation_state_json, meal_assignments, timestamps.</reason>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/src/routes/meal_plan.rs</path>
        <kind>module</kind>
        <symbol>Route handlers (show_meal_calendar, generate_meal_plan, etc.)</symbol>
        <lines>1-100</lines>
        <reason>HTTP route handlers for meal planning. Story 3.11 must update these to call MealPlanQueries::get_active_meal_plan and handle None case (no active plan).</reason>
      </artifact>
    </code>
    <dependencies>
      <rust>
        <dependency name="evento" version="1.4" features="sqlite-migrator">Event sourcing framework with SQLite backend. Provides aggregate pattern, event store, subscription handlers.</dependency>
        <dependency name="sqlx" version="0.8" features="runtime-tokio,sqlite,chrono,uuid">Async SQL query builder with compile-time verification (disabled per tech spec). Used for read model queries and projections.</dependency>
        <dependency name="axum" version="0.8" features="macros">HTTP server framework. Route handlers return Html&lt;String&gt; or Redirect responses.</dependency>
        <dependency name="askama" version="0.14">Compile-time type-safe HTML templates. Used for server-side rendering of dashboard and calendar views.</dependency>
        <dependency name="chrono" version="0.4" features="serde">Date/time handling for meal plan dates and timestamps.</dependency>
        <dependency name="serde" version="1.0" features="derive">Serialization for rotation_state JSON field in meal_plans table.</dependency>
        <dependency name="uuid" version="1.10" features="v4,serde">UUIDs for meal_plan_id and meal_assignment_id generation.</dependency>
      </rust>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint id="1" type="architecture">Event Sourcing Pattern: All state changes must be recorded as immutable events in evento event store. Read models (meal_plans, meal_assignments tables) are projections updated via evento subscription handlers.</constraint>
    <constraint id="2" type="architecture">CQRS: Commands write events to event store, queries read from materialized view tables. No direct database writes in command handlers - use evento::create() API.</constraint>
    <constraint id="3" type="database">Database Constraint: Unique partial index on meal_plans(user_id) WHERE status='active' ensures exactly one active plan per user. Projection handler must UPDATE existing active plans to status='archived' before INSERT new plan to avoid constraint violation.</constraint>
    <constraint id="4" type="database">Transaction Atomicity: All read model updates must occur within a single database transaction (BEGIN...COMMIT) to ensure consistency. Use pool.begin().await? and tx.commit().await?.</constraint>
    <constraint id="5" type="database">Idempotency: Projection handlers must check if event already processed to prevent duplicate inserts on event replay. Use SELECT 1 FROM meal_plans WHERE id=? before INSERT.</constraint>
    <constraint id="6" type="testing">TDD Enforced: Write tests first (unit, integration, E2E), then implement to pass tests. Target 80% code coverage via cargo tarpaulin.</constraint>
    <constraint id="7" type="testing">Test Pyramid: Unit tests (domain logic), integration tests (HTTP routes + database), E2E tests (Playwright for full user flows). Integration tests must use in-memory SQLite database.</constraint>
    <constraint id="8" type="naming">Rust Conventions: Events in past tense (MealPlanGenerated), commands imperative (GenerateMealPlan), functions snake_case (get_active_meal_plan), enums PascalCase (MealPlanStatus).</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>MealPlanQueries::get_active_meal_plan</name>
      <kind>async function</kind>
      <signature>pub async fn get_active_meal_plan(user_id: &amp;str, pool: &amp;SqlitePool) -&gt; Result&lt;Option&lt;MealPlanReadModel&gt;, sqlx::Error&gt;</signature>
      <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/read_model.rs:54-71</path>
      <usage>Call from dashboard and calendar route handlers to load active meal plan for authenticated user. Returns None if no active plan exists.</usage>
    </interface>
    <interface>
      <name>MealPlanQueries::get_active_meal_plan_with_assignments</name>
      <kind>async function</kind>
      <signature>pub async fn get_active_meal_plan_with_assignments(user_id: &amp;str, pool: &amp;SqlitePool) -&gt; Result&lt;Option&lt;MealPlanWithAssignments&gt;, sqlx::Error&gt;</signature>
      <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/read_model.rs:108-125</path>
      <usage>Convenience function that fetches active meal plan with all meal assignments joined. Use for calendar view template rendering.</usage>
    </interface>
    <interface>
      <name>meal_plan_generated_handler</name>
      <kind>evento subscription handler</kind>
      <signature>#[evento::handler(MealPlanAggregate)] pub async fn meal_plan_generated_handler&lt;E: Executor&gt;(context: &amp;Context&lt;'_, E&gt;, event: EventDetails&lt;MealPlanGenerated&gt;) -&gt; anyhow::Result&lt;()&gt;</signature>
      <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/read_model.rs:390-463</path>
      <usage>CRITICAL: Evento subscription handler registered in main.rs. Projects MealPlanGenerated events to meal_plans and meal_assignments tables. Enforces single active plan constraint by archiving existing active plans before insert.</usage>
    </interface>
    <interface>
      <name>meal_plan_projection</name>
      <kind>evento subscription builder</kind>
      <signature>pub fn meal_plan_projection(pool: SqlitePool) -&gt; evento::SubscribeBuilder&lt;evento::Sqlite&gt;</signature>
      <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/read_model.rs:711-720</path>
      <usage>Factory function to create evento subscription with all meal plan projection handlers. Must be called in main.rs startup to register subscriptions.</usage>
    </interface>
  </interfaces>

  <tests>
    <standards>
Testing strategy per solution-architecture.md section 15: TDD enforced with 80% code coverage target (cargo tarpaulin). Three-tier test pyramid: (1) Unit tests for domain logic in crates/meal_planning/tests/ using in-memory evento executor, (2) Integration tests for HTTP routes and database projections in tests/meal_plan_tests.rs using real SQLite database, (3) E2E tests for full user flows in e2e/tests/meal-planning.spec.ts using Playwright. All database tests must use transactions rolled back after each test for isolation. Integration tests verify evento subscription handlers execute correctly by emitting events and querying read models.</standards>
    <locations>
      <location>crates/meal_planning/tests/</location>
      <location>tests/meal_plan_integration_tests.rs</location>
      <location>e2e/tests/meal-planning.spec.ts</location>
    </locations>
    <ideas>
      <idea ac="1,2">Unit test: Test meal_plan_generated_handler with in-memory SQLite. Emit MealPlanGenerated event, verify meal_plans table contains one row with status='active'. Emit second event for same user, verify first plan status='archived' and second plan status='active'. Verify constraint enforced.</idea>
      <idea ac="3,4,8">Integration test: Generate meal plan via POST /plan/generate → Close HTTP client → Create new HTTP client with same auth token → GET /dashboard → Verify today's meals displayed from active plan. Tests cross-session persistence.</idea>
      <idea ac="5">Integration test: Generate meal plan → POST /plan/regenerate → Query meal_plans table → Verify old plan has status='archived', new plan has status='active', meal_plan_id changed (new ID created).</idea>
      <idea ac="9">Integration test: Generate meal plan → POST /plan/meal/:id/replace → Query meal_plans table → Verify meal_plan_id unchanged (stable ID), meal_assignments table updated with new recipe_id.</idea>
      <idea ac="10">Unit test: Attempt to INSERT two meal plans with status='active' for same user_id → Expect UNIQUE constraint violation error from SQLite.</idea>
      <idea ac="3">E2E test (Playwright): User logs in → Generate meal plan → Close browser → Reopen browser → Login again → Visit /dashboard → Verify meal plan loaded and today's meals displayed. Tests cross-browser-session persistence.</idea>
      <idea>Coverage test: Run cargo tarpaulin --all-features on crates/meal_planning → Verify ≥80% coverage for read_model.rs projection handlers and query functions.</idea>
    </ideas>
  </tests>
</story-context>
