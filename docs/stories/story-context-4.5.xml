<?xml version="1.0" encoding="UTF-8"?>
<story-context>
  <metadata>
    <epic_id>4</epic_id>
    <story_id>5</story_id>
    <story_title>Shopping List Item Checkoff</story_title>
    <generated_at>2025-10-18T00:00:00Z</generated_at>
    <status>ContextReadyDraft</status>
  </metadata>

  <story_definition>
    <user_story>
      As a user shopping at the store,
      I want to check off items as I collect them,
      so that I track progress and avoid missing items.
    </user_story>

    <acceptance_criteria>
      <criterion id="1">Each shopping list item has checkbox</criterion>
      <criterion id="2">Tapping/clicking checkbox marks item as collected (strike-through styling)</criterion>
      <criterion id="3">Checked state persists across page refreshes</criterion>
      <criterion id="4">Progress indicator at top: "{checked} of {total} items collected"</criterion>
      <criterion id="5">Filter options: "Show All", "Show Remaining", "Show Collected"</criterion>
      <criterion id="6">Checked items move to bottom of category section</criterion>
      <criterion id="7">Checking all items in category collapses that section automatically</criterion>
      <criterion id="8">Reset button to uncheck all items (for next shopping trip)</criterion>
    </acceptance_criteria>

    <prerequisites>
      - User has active meal plan (Story 3.1-3.3)
      - Shopping list has been generated (Story 4.1)
      - Shopping list displays with category grouping (Story 4.2)
      - Shopping list updates on meal replacement (Story 4.4)
    </prerequisites>
  </story_definition>

  <architecture_context>
    <patterns>
      <pattern name="Event Sourcing with evento">
        <description>ShoppingList aggregate manages state via evento event sourcing framework</description>
        <implementation>
          - ShoppingListItemChecked event captures checkbox state changes
          - ShoppingListReset event for bulk uncheck operation
          - Read model projections update shopping_list_items.is_collected column
          - All checkbox state changes maintain full audit trail
        </implementation>
        <constraints>
          - Events are immutable and cannot be deleted
          - State reconstruction via event replay
          - Projections run asynchronously via evento subscriptions
        </constraints>
      </pattern>

      <pattern name="CQRS">
        <description>Command/Query separation with read model projections</description>
        <commands>
          - MarkItemCollectedCommand: Toggle single item checkbox
          - ResetShoppingListCommand: Uncheck all items in shopping list
        </commands>
        <queries>
          - Read from shopping_list_items table filtered by is_collected
          - Aggregate counts for progress indicator
        </queries>
        <projections>
          - project_shopping_list_item_checked: Updates is_collected column
          - project_shopping_list_reset: Bulk uncheck via SQL UPDATE
        </projections>
      </pattern>

      <pattern name="Progressive Enhancement with TwinSpark">
        <description>Server-rendered HTML with AJAX enhancements</description>
        <implementation>
          - Checkbox toggles work via TwinSpark AJAX without full page reload
          - Server returns HTML fragments for updated items
          - Falls back to traditional form POST if JavaScript disabled
          - LocalStorage provides offline-first experience
        </implementation>
        <twinspark_attributes>
          - ts-req: AJAX endpoint URL
          - ts-req-method: HTTP method (POST)
          - ts-target: CSS selector for element to update
          - ts-swap: Swap strategy (outerHTML, innerHTML, etc.)
        </twinspark_attributes>
      </pattern>

      <pattern name="Offline-First PWA">
        <description>LocalStorage backup for offline checkbox persistence</description>
        <implementation>
          - LocalStorage caches checkbox state for offline use
          - Service worker ensures shopping list page cached
          - Background sync queues checkbox changes when offline
          - Automatic sync when connectivity restored
        </implementation>
      </pattern>
    </patterns>

    <technology_stack>
      <backend>
        <language>Rust 1.90+</language>
        <http_framework>Axum 0.8+</http_framework>
        <templating>Askama 0.14+ (compile-time type-safe templates)</templating>
        <event_sourcing>evento 1.4+ (SQLite-based ES/CQRS framework)</event_sourcing>
        <database>SQLite 3.45+ with WAL mode</database>
        <query_builder>SQLx 0.8+ (async, compile-time SQL verification DISABLED)</query_builder>
        <validation>validator 0.20+ (derive-based validation)</validation>
      </backend>

      <frontend>
        <progressive_enhancement>TwinSpark (declarative AJAX attributes)</progressive_enhancement>
        <css_framework>Tailwind CSS 4.1+ (utility-first)</css_framework>
        <offline_storage>LocalStorage API (browser native)</offline_storage>
        <service_worker>Workbox 7.1+ (PWA offline caching)</service_worker>
      </frontend>
    </technology_stack>

    <project_structure>
      <domain_crate path="crates/shopping">
        <purpose>Shopping list domain logic and event sourcing</purpose>
        <files>
          <file path="src/events.rs">
            - ShoppingListItemChecked event (NEW)
            - ShoppingListReset event (NEW)
            - ShoppingListGenerated event (EXISTING)
            - ShoppingListRecalculated event (EXISTING)
          </file>
          <file path="src/commands.rs">
            - MarkItemCollectedCommand (NEW)
            - ResetShoppingListCommand (NEW)
            - GenerateShoppingListCommand (EXISTING)
            - RecalculateShoppingListCommand (EXISTING)
          </file>
          <file path="src/aggregate.rs">
            - ShoppingListAggregate (EXISTING)
            - shopping_list_item_checked handler (NEW)
            - shopping_list_reset handler (NEW)
          </file>
          <file path="src/read_model.rs">
            - project_shopping_list_item_checked (NEW)
            - project_shopping_list_reset (NEW)
            - get_shopping_list_by_week (EXISTING)
            - validate_week_date (EXISTING)
          </file>
        </files>
      </domain_crate>

      <http_layer path="src/routes/shopping.rs">
        <purpose>HTTP route handlers for shopping list endpoints</purpose>
        <routes>
          <route method="POST" path="/shopping/items/:id/check">
            Toggle checkbox for single item (AC #2)
          </route>
          <route method="POST" path="/shopping/:week/reset">
            Reset all checkboxes for shopping list (AC #8)
          </route>
          <route method="GET" path="/shopping">
            Display shopping list with filter support (AC #5)
          </route>
        </routes>
      </http_layer>

      <templates path="templates">
        <pages>
          <file path="pages/shopping-list.html">
            Main shopping list page with progress indicator, filter buttons, reset button
          </file>
        </pages>
        <components>
          <file path="components/shopping-item.html">
            Individual shopping item with checkbox, TwinSpark attributes, strike-through styling
          </file>
        </components>
        <partials>
          <file path="partials/shopping-category.html">
            Category section with auto-collapse logic
          </file>
        </partials>
      </templates>

      <javascript path="static/js">
        <file path="shopping-offline.js">
          LocalStorage management for offline checkbox persistence (NEW)
        </file>
        <file path="category-collapse.js">
          Auto-collapse logic for fully checked categories (NEW)
        </file>
      </javascript>

      <database path="migrations">
        <migration name="04_add_collected_at_to_shopping_list_items.sql">
          ALTER TABLE shopping_list_items ADD COLUMN collected_at TEXT;
          (Optional: Add timestamp for audit trail)
        </migration>
      </database>
    </project_structure>
  </architecture_context>

  <existing_codebase>
    <shopping_domain>
      <events>
        <event name="ShoppingListGenerated">
          <fields>
            - user_id: String
            - meal_plan_id: String
            - week_start_date: String (ISO 8601)
            - items: Vec&lt;ShoppingListItem&gt;
            - generated_at: String (RFC3339)
          </fields>
        </event>

        <event name="ShoppingListRecalculated">
          <fields>
            - items: Vec&lt;ShoppingListItem&gt;
            - recalculated_at: String (RFC3339)
          </fields>
        </event>

        <event name="ShoppingListItemCollected">
          <status>Defined in events.rs but not yet implemented</status>
          <fields>
            - item_index: usize
            - collected: bool
            - collected_at: String (RFC3339)
          </fields>
          <note>This event is referenced in code but handler not implemented in Story 4.1-4.4</note>
        </event>
      </events>

      <aggregate name="ShoppingListAggregate">
        <state>
          - shopping_list_id: String
          - user_id: String
          - meal_plan_id: String
          - week_start_date: String
          - items: Vec&lt;ShoppingListItem&gt;
          - generated_at: String
        </state>
        <handlers>
          - shopping_list_generated (EXISTING)
          - shopping_list_recalculated (EXISTING)
          - shopping_list_item_collected (STUB - needs implementation)
        </handlers>
      </aggregate>

      <read_model>
        <tables>
          <table name="shopping_lists">
            <columns>
              - id TEXT PRIMARY KEY
              - user_id TEXT NOT NULL
              - meal_plan_id TEXT NOT NULL
              - week_start_date TEXT NOT NULL (ISO 8601 Monday)
              - generated_at TEXT NOT NULL (RFC3339)
            </columns>
            <indexes>
              - idx_shopping_lists_user (user_id)
              - idx_shopping_lists_meal_plan (meal_plan_id)
              - idx_shopping_lists_week (user_id, week_start_date)
            </indexes>
          </table>

          <table name="shopping_list_items">
            <columns>
              - id TEXT PRIMARY KEY
              - shopping_list_id TEXT NOT NULL
              - ingredient_name TEXT NOT NULL
              - quantity REAL NOT NULL
              - unit TEXT NOT NULL
              - category TEXT NOT NULL (CHECK: Produce, Dairy, Meat, Pantry, Frozen, Bakery, Other)
              - is_collected INTEGER NOT NULL DEFAULT 0 (Boolean: 0=false, 1=true)
            </columns>
            <indexes>
              - idx_shopping_list_items_list (shopping_list_id)
              - idx_shopping_list_items_category (shopping_list_id, category)
            </indexes>
            <note>is_collected column already exists - Story 4.2 added it with default 0</note>
          </table>
        </tables>

        <projections>
          - project_shopping_list_generated: Inserts shopping_lists + shopping_list_items
          - project_shopping_list_recalculated: Updates shopping_list_items, preserves is_collected state
        </projections>

        <queries>
          - get_shopping_list_by_week(user_id, week_start_date): Returns ShoppingListData with grouped items
          - validate_week_date(week_start_date): Validates Monday, current/future weeks only, max 4 weeks ahead
        </queries>
      </read_model>

      <domain_services>
        <service name="IngredientAggregationService">
          <purpose>Aggregates ingredients, normalizes units, sums quantities</purpose>
          <location>crates/shopping/src/aggregation.rs</location>
        </service>

        <service name="CategorizationService">
          <purpose>Maps ingredients to grocery store categories</purpose>
          <location>crates/shopping/src/categorization.rs</location>
          <categories>Produce, Dairy, Meat, Pantry, Frozen, Bakery, Other</categories>
        </service>
      </domain_services>
    </shopping_domain>

    <routes>
      <route path="/shopping" method="GET">
        <handler>show_shopping_list</handler>
        <query_params>
          - week: Optional&lt;String&gt; (ISO 8601 Monday, defaults to current week)
        </query_params>
        <returns>HTML page with shopping list grouped by category</returns>
        <template>pages/shopping-list.html</template>
      </route>

      <route path="/shopping/generate" method="POST">
        <handler>generate_shopping_list_handler</handler>
        <form_data>
          - week: Optional&lt;String&gt; (defaults to current week)
        </form_data>
        <action>Generates shopping list for selected week from active meal plan</action>
        <redirects_to>/shopping?week={selected_week}</redirects_to>
      </route>

      <route path="/shopping/refresh" method="GET">
        <handler>refresh_shopping_list</handler>
        <purpose>Returns shopping list content fragment for TwinSpark polling (Story 4.4)</purpose>
        <query_params>
          - week: Required&lt;String&gt; (ISO 8601 Monday)
        </query_params>
        <returns>HTML fragment (partials/shopping-list-content.html)</returns>
      </route>
    </routes>

    <templates>
      <template name="shopping-list.html">
        <status>EXISTS - needs modification for checkboxes</status>
        <current_features>
          - Week selector dropdown (current + 4 future weeks)
          - Category grouping with item counts
          - Collapsible category sections
          - Real-time updates via TwinSpark polling (Story 4.4)
        </current_features>
        <needed_additions>
          - Checkboxes on each item (AC #1)
          - Progress indicator at top (AC #4)
          - Filter buttons: Show All, Show Remaining, Show Collected (AC #5)
          - Reset button (AC #8)
          - Strike-through styling for checked items (AC #2)
          - Reordering: checked items to bottom (AC #6)
          - Auto-collapse when category fully checked (AC #7)
        </needed_additions>
      </template>

      <template name="shopping-list-content.html">
        <status>EXISTS - partial template for TwinSpark updates</status>
        <location>templates/partials/shopping-list-content.html</location>
        <purpose>AJAX-updatable content fragment</purpose>
      </template>
    </templates>
  </existing_codebase>

  <dependencies>
    <rust_dependencies>
      <dependency name="evento" version="1.4">
        <features>sqlite-migrator</features>
        <usage>Event sourcing framework, aggregate pattern, subscriptions</usage>
      </dependency>

      <dependency name="sqlx" version="0.8">
        <features>runtime-tokio, sqlite, chrono, uuid</features>
        <usage>Async database queries, read model projections</usage>
      </dependency>

      <dependency name="axum" version="0.8">
        <features>macros</features>
        <usage>HTTP server, route handlers, middleware</usage>
      </dependency>

      <dependency name="askama" version="0.14">
        <usage>Compile-time type-safe HTML templates</usage>
      </dependency>

      <dependency name="serde" version="1.0">
        <features>derive</features>
        <usage>JSON serialization for events and API responses</usage>
      </dependency>

      <dependency name="chrono" version="0.4">
        <features>serde</features>
        <usage>Date/time handling for timestamps</usage>
      </dependency>

      <dependency name="validator" version="0.20">
        <features>derive</features>
        <usage>Server-side form validation</usage>
      </dependency>

      <dependency name="anyhow" version="1.0">
        <usage>Error handling in async functions</usage>
      </dependency>

      <dependency name="thiserror" version="1.0">
        <usage>Custom error types for domain logic</usage>
      </dependency>
    </rust_dependencies>

    <javascript_dependencies>
      <dependency name="TwinSpark">
        <version>latest</version>
        <usage>Declarative AJAX attributes for progressive enhancement</usage>
        <location>static/js/twinspark.js</location>
      </dependency>

      <dependency name="LocalStorage API">
        <type>Browser Native</type>
        <usage>Offline checkbox state persistence</usage>
      </dependency>
    </javascript_dependencies>
  </dependencies>

  <testing_standards>
    <approach>TDD (Test-Driven Development)</approach>
    <coverage_target>80%+ code coverage (cargo-tarpaulin)</coverage_target>

    <unit_tests>
      <location>crates/shopping/tests/</location>
      <test_cases>
        <test name="test_mark_item_collected_command">
          - Validate item exists in shopping list
          - Validate user owns shopping list
          - Toggle is_collected state (true → false, false → true)
          - Emit ShoppingListItemChecked event
        </test>

        <test name="test_reset_shopping_list_command">
          - Validate shopping list exists
          - Validate user owns shopping list
          - Uncheck all items (set is_collected = false)
          - Emit ShoppingListReset event
        </test>

        <test name="test_shopping_list_item_checked_aggregate_handler">
          - Apply ShoppingListItemChecked event to aggregate
          - Verify aggregate state updated (if needed)
        </test>

        <test name="test_shopping_list_reset_aggregate_handler">
          - Apply ShoppingListReset event to aggregate
          - Verify aggregate state updated (if needed)
        </test>
      </test_cases>
    </unit_tests>

    <integration_tests>
      <location>tests/shopping_checkbox_tests.rs</location>
      <test_cases>
        <test name="test_post_shopping_items_check_route">
          - POST /shopping/items/:id/check with is_collected=true
          - Verify event emitted
          - Verify read model updated
          - Verify HTML fragment returned with strike-through styling
        </test>

        <test name="test_post_shopping_reset_route">
          - POST /shopping/:week/reset
          - Verify all items unchecked in read model
          - Verify redirect to /shopping?week={week}
        </test>

        <test name="test_shopping_list_filter_query">
          - GET /shopping?filter=remaining
          - Verify only unchecked items returned
          - GET /shopping?filter=collected
          - Verify only checked items returned
        </test>

        <test name="test_projection_preserves_checked_state">
          - Check item via command
          - Trigger meal replacement (ShoppingListRecalculated event)
          - Verify is_collected state preserved for existing items
        </test>
      </test_cases>
    </integration_tests>

    <e2e_tests>
      <location>e2e/tests/shopping-checkbox.spec.ts</location>
      <framework>Playwright 1.56+ (TypeScript)</framework>
      <test_cases>
        <test name="test_checkbox_interaction">
          - Navigate to shopping list page
          - Click checkbox on item
          - Verify strike-through styling applied
          - Refresh page
          - Verify item still checked (persistence)
        </test>

        <test name="test_progress_indicator">
          - Check 3 items out of 10
          - Verify progress shows "3 of 10 items collected"
          - Check 7 more items
          - Verify progress shows "10 of 10 items collected"
        </test>

        <test name="test_filter_functionality">
          - Check some items
          - Click "Show Remaining" filter
          - Verify only unchecked items visible
          - Click "Show Collected" filter
          - Verify only checked items visible
        </test>

        <test name="test_offline_checkbox_persistence">
          - Disconnect network (Playwright offline mode)
          - Check items
          - Verify items visually checked
          - Refresh page (service worker serves cached page)
          - Verify items still checked (LocalStorage)
          - Reconnect network
          - Verify changes synced to server
        </test>

        <test name="test_auto_collapse_category">
          - Check all items in Produce category
          - Verify Produce section auto-collapses
          - Uncheck one item
          - Verify Produce section auto-expands
        </test>

        <test name="test_reset_button">
          - Check multiple items
          - Click "Reset Checklist" button
          - Verify confirmation dialog appears
          - Confirm reset
          - Verify all items unchecked
          - Verify success message displayed
        </test>
      </test_cases>
    </e2e_tests>

    <previous_story_testing_patterns>
      <pattern source="Story 4.1">
        - Unit tests for domain services (IngredientAggregationService, CategorizationService)
        - Integration tests for evento projections
        - Performance tests (<2 seconds for 14 recipes)
        - Coverage: 80%+ for shopping crate
      </pattern>

      <pattern source="Story 4.4">
        - Real-time update tests with TwinSpark polling
        - Meal replacement recalculation tests
        - Preservation of is_collected state during recalculation
        - <1 second update performance requirement
      </pattern>
    </previous_story_testing_patterns>
  </testing_standards>

  <implementation_tasks>
    <task id="1" priority="1">
      <title>Implement checkbox toggle command and event (AC: #1, #2, #3)</title>
      <subtasks>
        <subtask id="1.1">Define ShoppingListItemChecked event in events.rs</subtask>
        <subtask id="1.2">Create MarkItemCollectedCommand in commands.rs</subtask>
        <subtask id="1.3">Implement mark_item_collected command handler</subtask>
        <subtask id="1.4">Add evento aggregate handler for shopping_list_item_checked</subtask>
        <subtask id="1.5">Write unit tests for command handler</subtask>
      </subtasks>
    </task>

    <task id="2" priority="2">
      <title>Create read model projection for checkbox state (AC: #3)</title>
      <subtasks>
        <subtask id="2.1">Implement project_shopping_list_item_checked handler</subtask>
        <subtask id="2.2">Update shopping_list_items.is_collected via SQL UPDATE</subtask>
        <subtask id="2.3">Store timestamp in collected_at column (add migration if needed)</subtask>
        <subtask id="2.4">Ensure projection is idempotent</subtask>
        <subtask id="2.5">Write integration tests for projection logic</subtask>
      </subtasks>
    </task>

    <task id="3" priority="3">
      <title>Implement HTTP route for checkbox toggle (AC: #2)</title>
      <subtasks>
        <subtask id="3.1">Create POST /shopping/items/:id/check route</subtask>
        <subtask id="3.2">Extract item_id from path and is_collected from form/JSON</subtask>
        <subtask id="3.3">Invoke mark_item_collected command</subtask>
        <subtask id="3.4">Return TwinSpark-compatible HTML fragment</subtask>
        <subtask id="3.5">Handle errors (item not found, permission denied)</subtask>
        <subtask id="3.6">Write integration tests for route</subtask>
      </subtasks>
    </task>

    <task id="4" priority="4">
      <title>Create checkbox UI component with TwinSpark (AC: #1, #2, #6)</title>
      <subtasks>
        <subtask id="4.1">Update templates/components/shopping-item.html with checkbox</subtask>
        <subtask id="4.2">Add TwinSpark attributes (ts-req, ts-req-method, ts-target, ts-swap)</subtask>
        <subtask id="4.3">Include hidden input for is_collected toggle value</subtask>
        <subtask id="4.4">Apply strike-through CSS (.line-through) when is_collected=true</subtask>
        <subtask id="4.5">Implement reordering: checked items to bottom via DOM/server</subtask>
        <subtask id="4.6">Test checkbox interaction</subtask>
      </subtasks>
    </task>

    <task id="5" priority="5">
      <title>Implement LocalStorage backup for offline persistence (AC: #3)</title>
      <subtasks>
        <subtask id="5.1">Create static/js/shopping-offline.js module</subtask>
        <subtask id="5.2">On checkbox change, store state in LocalStorage</subtask>
        <subtask id="5.3">On page load, read LocalStorage and apply checked states</subtask>
        <subtask id="5.4">Sync LocalStorage with server on successful POST</subtask>
        <subtask id="5.5">Handle offline scenario: queue changes, sync when online</subtask>
        <subtask id="5.6">Test offline checkbox persistence</subtask>
      </subtasks>
    </task>

    <task id="6" priority="6">
      <title>Build progress indicator (AC: #4)</title>
      <subtasks>
        <subtask id="6.1">Query shopping_list_items for total count and checked count</subtask>
        <subtask id="6.2">Pass progress data to template context</subtask>
        <subtask id="6.3">Render progress indicator at top of page</subtask>
        <subtask id="6.4">Add progress bar visual (optional)</subtask>
        <subtask id="6.5">Update progress indicator dynamically via TwinSpark</subtask>
        <subtask id="6.6">Test progress calculation accuracy</subtask>
      </subtasks>
    </task>

    <task id="7" priority="7">
      <title>Implement filter options (AC: #5)</title>
      <subtasks>
        <subtask id="7.1">Add filter buttons to shopping-list.html template</subtask>
        <subtask id="7.2">Create route GET /shopping?filter=all|remaining|collected</subtask>
        <subtask id="7.3">Modify shopping list query to filter by is_collected</subtask>
        <subtask id="7.4">Apply active state styling to selected filter</subtask>
        <subtask id="7.5">Use TwinSpark to update list without full page reload</subtask>
        <subtask id="7.6">Test all three filter states</subtask>
      </subtasks>
    </task>

    <task id="8" priority="8">
      <title>Implement category auto-collapse (AC: #7)</title>
      <subtasks>
        <subtask id="8.1">Add JavaScript logic to detect fully checked categories</subtask>
        <subtask id="8.2">Trigger collapse animation when last item checked</subtask>
        <subtask id="8.3">Store collapsed state in LocalStorage per category</subtask>
        <subtask id="8.4">On page load, restore collapsed state</subtask>
        <subtask id="8.5">Allow manual expand/collapse override</subtask>
        <subtask id="8.6">Test auto-collapse behavior</subtask>
      </subtasks>
    </task>

    <task id="9" priority="9">
      <title>Add reset button (AC: #8)</title>
      <subtasks>
        <subtask id="9.1">Create "Reset Checklist" button in template</subtask>
        <subtask id="9.2">Implement route POST /shopping/:week/reset</subtask>
        <subtask id="9.3">Create ResetShoppingListCommand</subtask>
        <subtask id="9.4">Emit ShoppingListReset event and update read model</subtask>
        <subtask id="9.5">Clear LocalStorage for all items in shopping list</subtask>
        <subtask id="9.6">Show confirmation dialog before reset</subtask>
        <subtask id="9.7">Display success message</subtask>
        <subtask id="9.8">Test reset functionality</subtask>
      </subtasks>
    </task>

    <task id="10" priority="10">
      <title>End-to-end testing (All ACs)</title>
      <subtasks>
        <subtask id="10.1">Write Playwright E2E test: check items, verify progress</subtask>
        <subtask id="10.2">Test persistence: check items, refresh, verify state</subtask>
        <subtask id="10.3">Test filter: check items, filter to "Remaining"</subtask>
        <subtask id="10.4">Test offline: disconnect, check items, reconnect, verify sync</subtask>
        <subtask id="10.5">Test auto-collapse: check all in category, verify collapse</subtask>
        <subtask id="10.6">Test reset: check items, reset, verify all unchecked</subtask>
        <subtask id="10.7">Verify 80%+ code coverage</subtask>
      </subtasks>
    </task>
  </implementation_tasks>

  <technical_specifications>
    <database_changes>
      <migration optional="true">
        <name>04_add_collected_at_to_shopping_list_items.sql</name>
        <sql>
          ALTER TABLE shopping_list_items
          ADD COLUMN collected_at TEXT;
        </sql>
        <purpose>Add timestamp for audit trail (optional for MVP)</purpose>
      </migration>

      <indexes>
        <index optional="true">
          <name>idx_shopping_list_items_collected</name>
          <table>shopping_list_items</table>
          <columns>(shopping_list_id, is_collected)</columns>
          <purpose>Optimize filter queries (Show Remaining, Show Collected)</purpose>
        </index>
      </indexes>
    </database_changes>

    <api_endpoints>
      <endpoint>
        <method>POST</method>
        <path>/shopping/items/:id/check</path>
        <request>
          <content_type>application/x-www-form-urlencoded</content_type>
          <body>
            <field name="is_collected" type="boolean">true or false</field>
          </body>
        </request>
        <response>
          <content_type>text/html</content_type>
          <body>HTML fragment with updated shopping item (strike-through if checked)</body>
        </response>
        <errors>
          - 404 Not Found: Item not found
          - 403 Forbidden: User does not own shopping list
          - 500 Internal Server Error: Command execution failed
        </errors>
      </endpoint>

      <endpoint>
        <method>POST</method>
        <path>/shopping/:week/reset</path>
        <request>
          <content_type>application/x-www-form-urlencoded</content_type>
        </request>
        <response>
          <type>redirect</type>
          <location>/shopping?week={week}</location>
        </response>
        <errors>
          - 404 Not Found: Shopping list not found
          - 403 Forbidden: User does not own shopping list
        </errors>
      </endpoint>

      <endpoint>
        <method>GET</method>
        <path>/shopping</path>
        <query_params>
          <param name="week" type="string" optional="true">ISO 8601 Monday (defaults to current week)</param>
          <param name="filter" type="enum" optional="true">all | remaining | collected (defaults to all)</param>
        </query_params>
        <response>
          <content_type>text/html</content_type>
          <body>Full shopping list page with filtered items</body>
        </response>
      </endpoint>
    </api_endpoints>

    <event_schemas>
      <event name="ShoppingListItemChecked">
        <fields>
          <field name="item_id" type="String">Shopping list item ID</field>
          <field name="is_collected" type="bool">true=collected, false=uncollected</field>
          <field name="checked_at" type="String">RFC3339 timestamp</field>
        </fields>
        <aggregator>ShoppingListAggregate</aggregator>
      </event>

      <event name="ShoppingListReset">
        <fields>
          <field name="reset_at" type="String">RFC3339 timestamp</field>
        </fields>
        <aggregator>ShoppingListAggregate</aggregator>
        <note>Unchecks all items in shopping list</note>
      </event>
    </event_schemas>

    <ui_components>
      <component name="shopping-item.html">
        <twinspark_example>
          <![CDATA[
          <div class="shopping-item" id="item-{{ item.id }}">
            <form ts-req="/shopping/items/{{ item.id }}/check"
                  ts-req-method="POST"
                  ts-target="#item-{{ item.id }}"
                  ts-swap="outerHTML">
              <input type="checkbox"
                     name="is_collected"
                     value="{{ !item.is_collected }}"
                     {% if item.is_collected %}checked{% endif %}
                     onchange="this.form.submit()" />
              <span class="{% if item.is_collected %}line-through{% endif %}">
                {{ item.quantity }} {{ item.unit }} {{ item.ingredient_name }}
              </span>
            </form>
          </div>
          ]]>
        </twinspark_example>
      </component>

      <component name="progress-indicator">
        <example>
          <![CDATA[
          <div class="progress-indicator">
            <span>{{ checked_count }} of {{ total_count }} items collected</span>
            <progress value="{{ checked_count }}" max="{{ total_count }}"></progress>
          </div>
          ]]>
        </example>
      </component>

      <component name="filter-buttons">
        <example>
          <![CDATA[
          <div class="filter-buttons">
            <button class="{% if filter == 'all' %}active{% endif %}"
                    ts-req="/shopping?week={{ week }}&filter=all"
                    ts-target="#shopping-list-content"
                    ts-swap="outerHTML">
              Show All
            </button>
            <button class="{% if filter == 'remaining' %}active{% endif %}"
                    ts-req="/shopping?week={{ week }}&filter=remaining"
                    ts-target="#shopping-list-content"
                    ts-swap="outerHTML">
              Show Remaining
            </button>
            <button class="{% if filter == 'collected' %}active{% endif %}"
                    ts-req="/shopping?week={{ week }}&filter=collected"
                    ts-target="#shopping-list-content"
                    ts-swap="outerHTML">
              Show Collected
            </button>
          </div>
          ]]>
        </example>
      </component>

      <component name="reset-button">
        <example>
          <![CDATA[
          <form action="/shopping/{{ week }}/reset" method="POST"
                onsubmit="return confirm('Are you sure? This will uncheck all items.')">
            <button type="submit" class="btn-reset">
              Reset Checklist
            </button>
          </form>
          ]]>
        </example>
      </component>
    </ui_components>

    <javascript_modules>
      <module name="shopping-offline.js">
        <purpose>LocalStorage management for offline checkbox persistence</purpose>
        <functions>
          - saveCheckboxState(itemId, isCollected): Save to LocalStorage
          - loadCheckboxStates(): Restore from LocalStorage on page load
          - syncWithServer(): Background sync when online
          - clearCheckboxStates(week): Clear LocalStorage for shopping list
        </functions>
        <localstorage_keys>
          - shopping_item_{item_id}: "true" or "false"
          - shopping_list_{week}_synced: timestamp of last sync
        </localstorage_keys>
      </module>

      <module name="category-collapse.js">
        <purpose>Auto-collapse categories when all items checked</purpose>
        <functions>
          - checkCategoryComplete(categoryName): Check if all items checked
          - collapseCategory(categoryName): Trigger collapse animation
          - expandCategory(categoryName): Expand category
          - saveCategoryState(categoryName, isCollapsed): Store in LocalStorage
          - restoreCategoryStates(): Restore on page load
        </functions>
        <localstorage_keys>
          - category_{category_name}_collapsed: "true" or "false"
        </localstorage_keys>
      </module>
    </javascript_modules>

    <performance_requirements>
      <requirement>
        <metric>Checkbox toggle response time</metric>
        <target>&lt;200ms from click to visual feedback</target>
        <measurement>Includes TwinSpark AJAX + server processing + DOM update</measurement>
      </requirement>

      <requirement>
        <metric>Progress indicator update</metric>
        <target>&lt;100ms after checkbox toggle</target>
        <measurement>Progress count recalculated and displayed</measurement>
      </requirement>

      <requirement>
        <metric>Filter operation</metric>
        <target>&lt;500ms to filter and re-render list</target>
        <measurement>Query + template render + TwinSpark swap</measurement>
      </requirement>

      <requirement>
        <metric>Reset operation</metric>
        <target>&lt;1 second to uncheck all items</target>
        <measurement>Bulk SQL UPDATE + page redirect</measurement>
      </requirement>
    </performance_requirements>
  </technical_specifications>

  <reference_documentation>
    <doc type="PRD">
      <path>docs/PRD.md</path>
      <relevant_sections>
        - FR-8: Shopping List Generation
        - FR-9: Multi-Week Shopping List Access
        - NFR-2: Performance requirements
        - NFR-4: 80% test coverage
      </relevant_sections>
    </doc>

    <doc type="Solution Architecture">
      <path>docs/solution-architecture.md</path>
      <relevant_sections>
        - Section 2: Event-Sourced Monolith pattern
        - Section 3.2: Data Models (shopping_lists, shopping_list_items)
        - Section 4: Progressive Enhancement with TwinSpark
        - Section 8.3: PWA Offline Strategy
        - Section 15: Testing Strategy
      </relevant_sections>
    </doc>

    <doc type="Epic Tech Spec">
      <path>docs/tech-spec-epic-4.md</path>
      <relevant_sections>
        - Shopping list domain architecture
        - Ingredient aggregation algorithms
        - Category-based grouping
        - Real-time updates with TwinSpark
      </relevant_sections>
    </doc>

    <doc type="Story Documentation">
      <story_4_1>
        <path>docs/stories/story-4.1.md</path>
        <learnings>
          - ShoppingList aggregate structure
          - IngredientAggregationService patterns
          - CategorizationService implementation
          - Database schema (shopping_lists, shopping_list_items)
          - Evento projection setup
        </learnings>
      </story_4_1>

      <story_4_2>
        <path>docs/stories/story-4.2.md</path>
        <learnings>
          - Category grouping UI patterns
          - Collapsible sections with details/summary
          - Tailwind CSS styling for categories
          - Empty category filtering
        </learnings>
      </story_4_2>

      <story_4_4>
        <path>docs/stories/story-4.4.md</path>
        <learnings>
          - TwinSpark polling for real-time updates
          - ShoppingListRecalculated event handling
          - Preserving is_collected state during recalculation
          - Partial template patterns (shopping-list-content.html)
          - Performance optimization (&lt;1 second updates)
        </learnings>
      </story_4_4>
    </doc>

    <doc type="TwinSpark Documentation">
      <path>docs/twinspark.md</path>
      <relevant_sections>
        - ts-req attribute usage
        - ts-swap strategies
        - Form submission with TwinSpark
        - Progressive enhancement patterns
      </relevant_sections>
    </doc>
  </reference_documentation>

  <constraints_and_considerations>
    <constraint type="Event Sourcing">
      - Events are immutable and cannot be deleted
      - Checkbox state changes must emit ShoppingListItemChecked events
      - Full audit trail maintained for compliance/debugging
    </constraint>

    <constraint type="Offline-First">
      - Checkbox toggles must work offline (LocalStorage)
      - Sync required when connectivity restored
      - Service worker caches shopping list page
      - Background sync API for queued changes
    </constraint>

    <constraint type="Progressive Enhancement">
      - Checkboxes must work without JavaScript (traditional form POST)
      - TwinSpark enhances with AJAX for better UX
      - Graceful degradation if TwinSpark unavailable
    </constraint>

    <constraint type="Performance">
      - Checkbox toggle &lt;200ms response time
      - Filter operation &lt;500ms
      - Reset operation &lt;1 second
      - All operations measured client-side (includes network latency)
    </constraint>

    <consideration type="UX">
      - Strike-through styling indicates checked items clearly
      - Checked items move to bottom for shopping efficiency
      - Progress indicator motivates completion
      - Auto-collapse reduces visual clutter
      - Reset confirmation prevents accidental data loss
    </consideration>

    <consideration type="Data Integrity">
      - ShoppingListRecalculated event (Story 4.4) preserves is_collected state
      - Checkbox state persists across meal replacements
      - Reset operation requires user confirmation
      - LocalStorage sync prevents data loss on network issues
    </consideration>

    <consideration type="Accessibility">
      - Checkboxes must be keyboard-accessible
      - Screen reader announces checked state
      - Progress indicator readable by assistive tech
      - Confirmation dialogs accessible (modal focus trap)
    </consideration>
  </constraints_and_considerations>

  <open_questions>
    <question id="1">
      <text>Should collected_at timestamp be stored in aggregate or only in read model?</text>
      <recommendation>Store in read model only (via projection) for simplicity. Aggregate doesn't need this data for business logic.</recommendation>
    </question>

    <question id="2">
      <text>Should filter state persist in URL query param or LocalStorage?</text>
      <recommendation>Use URL query param (?filter=remaining) for shareable links and browser history. LocalStorage optional for "sticky" filter preference.</recommendation>
    </question>

    <question id="3">
      <text>Should auto-collapse happen client-side (JavaScript) or server-side (template logic)?</text>
      <recommendation>Client-side JavaScript for immediate feedback. Server renders collapsed state based on data (all items checked) as fallback.</recommendation>
    </question>

    <question id="4">
      <text>Should reset button appear on empty shopping lists?</text>
      <recommendation>No - hide reset button when list is empty or all items already unchecked. Only show when actionable.</recommendation>
    </question>

    <question id="5">
      <text>How should offline checkbox changes sync when multiple devices involved?</text>
      <recommendation>Last-write-wins on server. Offline changes sync on reconnect. Future: conflict resolution UI if needed.</recommendation>
    </question>
  </open_questions>

  <implementation_notes>
    <note priority="high">
      The is_collected column already exists in shopping_list_items table (added in Story 4.2 migration).
      No new migration needed unless collected_at timestamp is desired for audit trail.
    </note>

    <note priority="high">
      ShoppingListRecalculated projection (Story 4.4) already preserves is_collected state during
      meal replacement. Checkbox implementation must ensure this behavior continues.
    </note>

    <note priority="medium">
      TwinSpark AJAX patterns from Story 4.4 can be reused for checkbox toggles.
      Refer to /shopping/refresh endpoint for partial template patterns.
    </note>

    <note priority="medium">
      LocalStorage keys should be scoped per user and per week to avoid conflicts across
      shopping lists. Format: shopping_item_{week}_{item_id}
    </note>

    <note priority="low">
      Consider adding visual feedback (spinner, pulse animation) during checkbox toggle
      to indicate server processing. TwinSpark supports loading states via CSS classes.
    </note>

    <note priority="low">
      Reset button confirmation dialog can use native browser confirm() for MVP.
      Future: custom modal with Tailwind styling for better UX.
    </note>
  </implementation_notes>

  <success_criteria>
    <criterion>All 8 acceptance criteria validated via E2E tests</criterion>
    <criterion>80%+ code coverage on shopping domain checkbox logic</criterion>
    <criterion>Checkbox toggle &lt;200ms response time (measured in E2E tests)</criterion>
    <criterion>Offline checkbox persistence works (Playwright offline mode test)</criterion>
    <criterion>No regressions in existing shopping list functionality (Stories 4.1-4.4)</criterion>
    <criterion>TDD approach followed: tests written before implementation</criterion>
    <criterion>Code review approved by tech lead</criterion>
    <criterion>Documentation updated (story status, context reference)</criterion>
  </success_criteria>
</story-context>
