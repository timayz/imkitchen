<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>4</epicId>
    <storyId>6</storyId>
    <title>Advance Preparation Reminder System</title>
    <status>Draft</status>
    <generatedAt>2025-10-18</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>/home/snapiz/projects/github/timayz/imkitchen/docs/stories/story-4.6.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>a user with advance-prep recipes in my meal plan</asA>
    <iWant>timely reminders for preparation tasks</iWant>
    <soThat>I successfully execute complex recipes</soThat>
    <tasks>
      - Task 1: Create notifications domain crate scaffold (AC: All)
      - Task 2: Define notification domain events (AC: #1, #2, #3)
      - Task 3: Implement notification commands (AC: #2, #5, #8)
      - Task 4: Build notification aggregate with evento (AC: All)
      - Task 5: Create notification read models and projections (AC: All)
      - Task 6: Implement reminder scheduling logic (AC: #2, #3, #4)
      - Task 7: Integrate Web Push API (AC: #5, #6)
      - Task 8: Build background notification scheduler worker (AC: #5)
      - Task 9: Create HTTP routes for notifications (AC: #7, #8)
      - Task 10: Build notification UI templates (AC: #6, #7, #8)
      - Task 11: Generate notification message text (AC: #4, #6)
      - Task 12: Handle notification deep linking (AC: #7)
      - Task 13: End-to-end testing (All ACs)
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="1">System scans meal plan for recipes with advance prep (marinade, rising, chilling, etc.)</criterion>
    <criterion id="2">Reminders scheduled automatically when meal plan generated</criterion>
    <criterion id="3">Reminder timing calculated from advance prep requirement and meal schedule</criterion>
    <criterion id="4">Example: "Marinate chicken 4 hours before" for Wednesday dinner → reminder sent Tuesday evening or Wednesday morning</criterion>
    <criterion id="5">Reminders delivered via push notification (if enabled)</criterion>
    <criterion id="6">Reminder displays: recipe name, specific prep task, timing guidance</criterion>
    <criterion id="7">Tapping reminder opens recipe detail with prep instructions highlighted</criterion>
    <criterion id="8">User can snooze reminder (1 hour, 2 hours, 4 hours)</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic 4 Story 4.6 Requirements</title>
        <section>Story 4.6: Advance Preparation Reminder System</section>
        <snippet>Prerequisites: Active meal plan includes recipes with advance prep requirements. Reminders scheduled automatically when meal plan generated. Reminder timing calculated from advance prep requirement and meal schedule.</snippet>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-4.md</path>
        <title>Epic 4 Technical Specification - Notification Domain</title>
        <section>Notifications Crate Architecture</section>
        <snippet>NotificationAggregate manages notification scheduling, delivery tracking, user preferences. Commands: ScheduleReminder, SendReminder, DismissNotification, SubscribeToPush. Events: ReminderScheduled, ReminderSent, ReminderDismissed, PushSubscriptionCreated. Background worker (tokio tasks) for scheduled notification delivery. VAPID-based Web Push API integration.</snippet>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-4.md</path>
        <title>Story 7: Advance Preparation Reminder Scheduling</title>
        <section>Reminder Scheduling Logic</section>
        <snippet>Given meal plan with Thursday dinner requiring 24-hour marinade, prep reminder scheduled for Wednesday 9am (24 hours before Thursday 6pm dinner). MealPlanGenerated event triggers ScheduleReminder command. ReminderScheduled event written to evento stream. calculate_reminder_time() function: meal Thursday 6pm, 24h prep → Wednesday 9am.</snippet>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-4.md</path>
        <title>Story 8: Background Notification Delivery</title>
        <section>Background Worker Pattern</section>
        <snippet>Background worker polls for due notifications every 1 minute. Query notifications with scheduled_time &lt;= now AND status='pending'. Send via Web Push API with VAPID signature. ReminderSent event written to evento stream. Exponential backoff retry (3 attempts: 1s, 2s, 4s).</snippet>
      </doc>
      <doc>
        <path>docs/solution-architecture.md</path>
        <title>Web Push Notifications Architecture</title>
        <section>9.3 Push Notifications</section>
        <snippet>Web Push API (browser standard, no vendor). Setup: User enables notifications → Browser generates push subscription (endpoint + keys) → POST subscription to /api/push-subscribe. Sending: Domain event triggers notification → Background worker queries push_subscriptions → Send via web-push crate with VAPID. Notification payload: title, body, icon, action buttons.</snippet>
      </doc>
      <doc>
        <path>docs/solution-architecture.md</path>
        <title>Event Sourcing Pattern with evento</title>
        <section>3.2 Data Models and Relationships</section>
        <snippet>evento manages event store schema internally. Aggregates rebuild state from event stream. Projections update read models via evento subscriptions. Example: RecipeCreated event → project_recipe_to_read_model subscription handler → INSERT into recipes table.</snippet>
      </doc>
      <doc>
        <path>docs/solution-architecture.md</path>
        <title>Testing Strategy</title>
        <section>15. Testing Strategy</section>
        <snippet>Unit tests: Domain aggregate logic (evento commands/events). Integration tests: HTTP routes, database projections. E2E tests: Full user flows (Playwright). Coverage target: 80%+ code coverage. TDD enforced: write test first, then code.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>crates/meal_planning/src/events.rs</path>
        <kind>event</kind>
        <symbol>MealPlanGenerated</symbol>
        <lines>51-57</lines>
        <reason>Evento subscription hook point: MealPlanGenerated event triggers ScheduleReminder commands for all meals with advance_prep_hours &gt; 0</reason>
      </artifact>
      <artifact>
        <path>crates/meal_planning/src/events.rs</path>
        <kind>struct</kind>
        <symbol>MealAssignment</symbol>
        <lines>36-42</lines>
        <reason>Contains meal metadata needed for reminder scheduling: date, meal_type, recipe_id, prep_required flag</reason>
      </artifact>
      <artifact>
        <path>crates/recipe/src/aggregate.rs</path>
        <kind>struct_field</kind>
        <symbol>Recipe.advance_prep_hours</symbol>
        <lines>30</lines>
        <reason>Source of advance prep requirement in hours (e.g., 24 for marinade). Used to calculate reminder scheduled_time.</reason>
      </artifact>
      <artifact>
        <path>crates/recipe/src/read_model.rs</path>
        <kind>query_function</kind>
        <symbol>get_recipe_by_id</symbol>
        <lines>336-364</lines>
        <reason>Query recipe details including advance_prep_hours when scheduling reminders. Interface to call from notifications crate.</reason>
      </artifact>
      <artifact>
        <path>crates/shopping/src/events.rs</path>
        <kind>event</kind>
        <symbol>ShoppingListGenerated</symbol>
        <lines>1-20</lines>
        <reason>Example evento event pattern to follow for ReminderScheduled, ReminderSent events. Shows bincode derives, AggregatorName pattern.</reason>
      </artifact>
      <artifact>
        <path>crates/shopping/src/aggregate.rs</path>
        <kind>aggregate</kind>
        <symbol>ShoppingListAggregate</symbol>
        <lines>1-50</lines>
        <reason>Example evento aggregate pattern to follow for NotificationAggregate. Shows evento::aggregator macro usage, event handlers.</reason>
      </artifact>
      <artifact>
        <path>crates/shopping/src/read_model.rs</path>
        <kind>projection</kind>
        <symbol>project_shopping_list_generated</symbol>
        <lines>1-80</lines>
        <reason>Example evento projection pattern for project_reminder_scheduled. Shows unsafe_oneshot usage, SQL INSERT with sqlx.</reason>
      </artifact>
      <artifact>
        <path>crates/shopping/tests/integration_tests.rs</path>
        <kind>test_module</kind>
        <symbol>setup_test_db</symbol>
        <lines>1-50</lines>
        <reason>Test harness pattern: in-memory SQLite, evento executor setup, migrations. Reuse for notifications integration tests.</reason>
      </artifact>
    </code>
    <dependencies>
      <rust>
        <package name="evento" version="1.4" features="sqlite-migrator" reason="Event sourcing framework for NotificationAggregate, projections, subscriptions"/>
        <package name="sqlx" version="0.8" features="runtime-tokio, sqlite, chrono, uuid" reason="Database access for read models (notifications, push_subscriptions tables)"/>
        <package name="tokio" version="1.40" features="full" reason="Async runtime for background notification worker (interval task)"/>
        <package name="chrono" version="0.4" features="serde" reason="Datetime calculations for scheduled_time, reminder timing logic"/>
        <package name="serde" version="1.0" features="derive" reason="Serialization for event data, notification payloads"/>
        <package name="bincode" version="2.0" reason="Event serialization for evento (Encode/Decode derives)"/>
        <package name="web-push" version="0.10+" reason="Web Push API client for VAPID-based push notifications (NEW DEPENDENCY)"/>
        <package name="thiserror" version="1.0" reason="Custom error types for notification domain"/>
        <package name="anyhow" version="1.0" reason="Error handling in command handlers"/>
        <package name="tracing" version="0.1" reason="Observability for background worker, notification delivery attempts"/>
      </rust>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint type="architecture">Event Sourcing: All state changes via evento events (ReminderScheduled, ReminderSent, ReminderDismissed, ReminderSnoozed). No direct database mutations.</constraint>
    <constraint type="architecture">CQRS: Separate commands (write) from queries (read). Commands emit events, projections update read models.</constraint>
    <constraint type="domain">Notification crate follows established pattern: events.rs, commands.rs, aggregate.rs, read_model.rs modules. Same structure as shopping/recipe crates.</constraint>
    <constraint type="integration">evento subscription: MealPlanGenerated event → scan meal_assignments for prep_required=true → schedule reminders for each meal with advance prep.</constraint>
    <constraint type="timing">For advance_prep_hours &gt;= 24h: schedule for 9am on day before meal. For 4-23h: schedule for (meal_time - prep_hours). For &lt; 4h: schedule day-of reminder 1 hour before.</constraint>
    <constraint type="background_worker">Tokio interval task polls every 1 minute. Query pending notifications with scheduled_time &lt;= now(). Send via Web Push API. Emit ReminderSent event.</constraint>
    <constraint type="retry_logic">Exponential backoff: 3 retry attempts with delays 1s, 2s, 4s. Mark notification as 'failed' after exhausting retries.</constraint>
    <constraint type="security">Web Push VAPID keys stored in config (environment variables in production). Push subscriptions include user_id for authorization checks.</constraint>
    <constraint type="testing">TDD enforced: Write failing test first, then implement. Unit tests for commands/aggregates, integration tests for projections/routes, E2E tests for full flow.</constraint>
    <constraint type="testing">Coverage target: 80%+ for notifications domain. Use in-memory SQLite for integration tests (pattern from shopping crate).</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>recipe::get_recipe_by_id</name>
      <kind>query_function</kind>
      <signature>pub async fn get_recipe_by_id(executor: &amp;impl Executor, recipe_id: &amp;str) -> Result&lt;Option&lt;RecipeWithDetails&gt;&gt;</signature>
      <path>crates/recipe/src/read_model.rs</path>
      <usage>Call from notifications crate to fetch recipe.advance_prep_hours, recipe.title when scheduling reminders</usage>
    </interface>
    <interface>
      <name>meal_planning::MealPlanGenerated</name>
      <kind>event</kind>
      <signature>pub struct MealPlanGenerated { pub user_id: String, pub start_date: String, pub meal_assignments: Vec&lt;MealAssignment&gt;, ... }</signature>
      <path>crates/meal_planning/src/events.rs</path>
      <usage>Subscribe to this event via evento::subscribe() in notifications crate to trigger reminder scheduling</usage>
    </interface>
    <interface>
      <name>evento::subscribe</name>
      <kind>function</kind>
      <signature>pub fn subscribe(name: &amp;str) -> SubscriptionBuilder</signature>
      <path>External: evento crate</path>
      <usage>Register evento subscription: evento::subscribe("reminder-scheduling").aggregator::&lt;MealPlanAggregate&gt;().handler(schedule_reminders_handler).run(&amp;executor)</usage>
    </interface>
    <interface>
      <name>web_push::WebPushClient</name>
      <kind>struct</kind>
      <signature>impl WebPushClient { pub async fn send(&amp;self, message: WebPushMessage) -> Result&lt;()&gt; }</signature>
      <path>External: web-push crate</path>
      <usage>Send push notifications to browser endpoints with VAPID signature</usage>
    </interface>
    <interface>
      <name>sqlx::query!</name>
      <kind>macro</kind>
      <signature>sqlx::query!("SQL", ...binds).execute(pool).await</signature>
      <path>External: sqlx crate</path>
      <usage>Execute SQL for projections (INSERT/UPDATE notifications table). Use parameterized queries for safety.</usage>
    </interface>
  </interfaces>

  <tests>
    <standards>
      TDD approach enforced: write failing test before implementation. Use in-memory SQLite for fast integration tests (setup_test_db pattern from shopping crate). Unit tests for domain logic (commands, aggregates, scheduling calculations). Integration tests for projections and HTTP routes. E2E tests with Playwright for notification delivery flow. Assertion pattern: Arrange-Act-Assert. Use descriptive test names. Coverage target: 80%+ code coverage via cargo tarpaulin.
    </standards>
    <locations>
      - crates/notifications/tests/ (unit and integration tests)
      - tests/notification_integration_tests.rs (root-level integration tests)
      - e2e/tests/notifications.spec.ts (Playwright E2E tests)
    </locations>
    <ideas>
      <test ac="1">Test: scan MealPlanGenerated event, verify reminders scheduled for all meals with prep_required=true</test>
      <test ac="2">Test: subscribe to MealPlanGenerated event, verify ScheduleReminderCommand invoked automatically</test>
      <test ac="3">Test: calculate_reminder_time() with 24h prep + Thursday 6pm meal → Wednesday 9am scheduled_time</test>
      <test ac="3">Test: calculate_reminder_time() with 4h prep + Wednesday 6pm meal → Wednesday 2pm scheduled_time</test>
      <test ac="4">Test: generate_notification_body() with 24h marinade → "Marinate chicken tonight for Thursday dinner: Chicken Tikka Masala"</test>
      <test ac="5">Test: background worker polls pending notifications, sends via Web Push API, emits ReminderSent event</test>
      <test ac="6">Test: notification payload includes recipe_title, prep_task, timing_guidance</test>
      <test ac="7">Test: notification deep link opens recipe detail with prep section highlighted (E2E)</test>
      <test ac="8">Test: SnoozeReminderCommand updates scheduled_time by 1h/2h/4h, projection updates database</test>
      <test ac="all">Integration test: Create meal plan → verify notifications table has pending reminders → mock time to trigger worker → verify status='sent'</test>
    </ideas>
  </tests>
</story-context>
