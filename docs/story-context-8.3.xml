<story-context id="bmad/bmm/workflows/4-implementation/story-context/8.3" v="1.0">
  <metadata>
    <epicId>8</epicId>
    <storyId>8.3</storyId>
    <title>Create Week Regeneration Route</title>
    <status>Draft</status>
    <generatedAt>2025-10-26</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>/home/snapiz/projects/github/timayz/imkitchen/docs/stories/story-8.3.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>backend developer</asA>
    <iWant>to create a POST route that regenerates a single future week's meal plan</iWant>
    <soThat>authenticated users can refresh individual weeks when their preferences or schedule changes</soThat>
    <tasks>
      - Define route handler function signature with Axum extractors
      - Load week from read model and verify ownership (authorization check)
      - Verify week authorization and lock status (not locked, not past, belongs to user)
      - Load current rotation state for meal plan batch
      - Load user's favorite recipes and meal planning preferences
      - Call Epic 7 algorithm to generate single week
      - Emit SingleWeekRegenerated evento event
      - Build JSON response with regenerated week data
      - Implement error handling for WeekLocked (403) and WeekAlreadyStarted (400)
      - Add structured logging and tracing
      - Write integration tests for successful regeneration, locked week, past week, unauthorized access
      - Write performance test (P95 &lt;500ms route overhead)
      - Register route in Axum router
    </tasks>
  </story>

  <acceptanceCriteria>
    1. Route `POST /plan/week/:week_id/regenerate` created
    2. Route verifies week belongs to user and is not locked (authorization + validation)
    3. Handler loads current rotation_state for meal plan batch
    4. Handler generates new meal assignments for week (calls `generate_single_week`)
    5. Handler commits `SingleWeekRegenerated` event to evento
    6. Handler regenerates shopping list for week (projection handles this)
    7. Returns 403 if week is locked (`is_locked == true` or `status == "current"`)
    8. Returns 400 if week already started (`status == "past"`)
    9. Integration test: POST regenerates future week successfully
    10. Integration test: POST on locked week returns 403
  </acceptanceCriteria>

  <artifacts>
    <docs>
      - Technical Specification: /home/snapiz/projects/github/timayz/imkitchen/docs/tech-spec-epic-8.md
        * Section: APIs and Interfaces - POST /plan/week/:week_id/regenerate
        * Section: Workflows and Sequencing - Week Regeneration Request Flow
        * Section: Data Models and Contracts - Week Regeneration Response
        * Section: Non-Functional Requirements - Reliability (week lock validation)

      - UX Specification: /home/snapiz/projects/github/timayz/imkitchen/docs/ux-specification.md
        * Section: User Flows - Flow 3: Meal Plan Disruption and Quick Recovery

      - TwinSpark Documentation: /home/snapiz/projects/github/timayz/imkitchen/docs/twinspark.md
        * Frontend: ts-req="/plan/week/:week_id/regenerate" ts-req-method="POST"
    </docs>

    <code>
      - Epic 7 Algorithm: /home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/algorithm.rs
        * Function: generate_single_week(recipes, preferences, &amp;mut rotation_state, week_start_date)
        * Returns: Result&lt;WeekMealPlan, Error&gt; with 21 meal assignments

      - Rotation State: /home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/rotation.rs
        * RotationState type for tracking recipe usage
        * Load from meal_plan_rotation_state table

      - Events: /home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/events.rs
        * SingleWeekRegenerated event struct
        * Fields: week_id, week_start_date, meal_assignments, updated_rotation_state

      - Read Model: /home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/read_model.rs
        * meal_plan_projection handler for SingleWeekRegenerated event
        * Projection: DELETE old assignments, INSERT new assignments, UPDATE shopping_lists

      - Example Test: /home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/tests/multi_week_projection_tests.rs
        * unsafe_oneshot pattern for synchronous event processing
    </code>

    <dependencies>
      - axum 0.7+ (HTTP routing, Path extractor)
      - sqlx 0.8+ (database queries)
      - evento 1.5+ (event emission)
      - serde, serde_json (JSON serialization)
      - chrono 0.4+ (week_start_date handling)
      - tracing 0.1+ (structured logging)
    </dependencies>
  </artifacts>

  <constraints>
    - Week Lock Rules: Current week (is_locked == true OR status == "current") cannot be regenerated
    - Past Week Rules: Weeks with status == "past" cannot be regenerated
    - Future Week Rules: Only weeks with status == "future" AND is_locked == false can be regenerated
    - Rotation State: Must preserve rotation state context across week regenerations for variety
    - Shopping List Regeneration: Happens asynchronously via evento projection (eventual consistency)
    - Performance Target: Route overhead P95 &lt;500ms (excluding algorithm execution time)
  </constraints>

  <interfaces>
    Route Signature:
    ```rust
    #[post("/plan/week/:week_id/regenerate")]
    async fn regenerate_week(
        Extension(user_id): Extension&lt;UserId&gt;,
        Path(week_id): Path&lt;String&gt;,
        Extension(db): Extension&lt;DatabasePool&gt;,
        Extension(executor): Extension&lt;EventoExecutor&gt;,
    ) -&gt; Result&lt;Json&lt;WeekResponse&gt;, ApiError&gt;
    ```

    Response Schema:
    ```json
    {
      "week": {
        "id": "week-uuid",
        "start_date": "2025-11-04",
        "status": "future",
        "is_locked": false,
        "meal_assignments": [
          // 21 regenerated assignments
        ],
        "shopping_list_id": "new-shopping-uuid"
      },
      "message": "Week regenerated successfully. Shopping list updated."
    }
    ```

    Error Responses:
    ```json
    {
      "error": "WeekLocked",
      "message": "Cannot regenerate current week. It is locked to prevent disrupting in-progress meals.",
      "status": 403
    }

    {
      "error": "WeekAlreadyStarted",
      "message": "Cannot regenerate a week that has already started.",
      "status": 400
    }
    ```

    Implementation Pattern:
    ```rust
    // 1. Load and authorize week
    let week: MealPlanReadModel = load_week(&db, &week_id, &user_id).await?;

    // 2. Validate lock status
    if week.is_locked || week.status == "current" {
        return Err(ApiError::WeekLocked);
    }
    if week.status == "past" {
        return Err(ApiError::WeekAlreadyStarted);
    }

    // 3. Load rotation state
    let mut rotation_state: RotationState = sqlx::query_as(
        "SELECT * FROM meal_plan_rotation_state WHERE generation_batch_id = ? AND user_id = ?"
    )
    .bind(&week.generation_batch_id)
    .bind(&user_id)
    .fetch_one(&db)
    .await?;

    // 4. Load recipes and preferences
    let recipes = load_favorite_recipes(&db, &user_id).await?;
    let preferences = load_user_preferences(&db, &user_id).await?;

    // 5. Call algorithm
    let regenerated_week = generate_single_week(
        recipes,
        preferences,
        &amp;mut rotation_state,
        week.start_date
    ).await?;

    // 6. Emit event
    let event = SingleWeekRegenerated {
        week_id: week_id.clone(),
        week_start_date: week.start_date,
        meal_assignments: regenerated_week.meal_assignments,
        updated_rotation_state: rotation_state,
    };
    executor.emit(event).await?;

    // 7. Return response
    Ok(Json(WeekResponse {
        week: regenerated_week,
        message: "Week regenerated successfully. Shopping list updated.".to_string(),
    }))
    ```

    Evento Event Schema:
    ```rust
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct SingleWeekRegenerated {
        pub week_id: String,                       // UUID from path param
        pub week_start_date: NaiveDate,            // Week start date (Monday)
        pub meal_assignments: Vec&lt;MealAssignment&gt;, // 21 new assignments
        pub updated_rotation_state: RotationState, // Modified state
    }
    ```
  </interfaces>

  <tests>
    <standards>
      - Coverage Target: 100% coverage for authorization and lock validation logic (critical business rules)
      - Security Testing: Verify cross-user regeneration prevention (403 Forbidden)
      - Business Rules: Test all lock/status edge cases (current, past, future, locked, unlocked)
      - Evento Integration: Verify projection updates read models correctly after event emission
    </standards>

    <locations>
      - Integration Tests: crates/api/tests/integration/test_regeneration.rs
      - Performance Tests: crates/api/tests/performance/route_latency_tests.rs
    </locations>

    <ideas>
      - Test: POST /plan/week/{future_week_id}/regenerate with valid JWT returns 200 OK
      - Test: Verify JSON response contains regenerated meal_assignments (21 items)
      - Test: Subscribe to SingleWeekRegenerated event using unsafe_oneshot
      - Test: Verify meal_assignments table has new assignments for week
      - Test: Verify shopping_lists table updated for the regenerated week
      - Test: POST on current week (is_locked == true) returns 403 WeekLocked
      - Test: POST on past week (status == "past") returns 400 WeekAlreadyStarted
      - Test: Create two test users, authenticate as user A, attempt to regenerate user B's week â†’ 403 Forbidden
      - Test: Verify rotation_state preserved and updated correctly after regeneration
      - Test: Verify structured logging includes week_id, user_id, week_status
      - Performance Test: Measure route overhead &lt;500ms P95 (mock algorithm to return immediately)
    </ideas>
  </tests>
</story-context>
