<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>7</epicId>
    <storyId>7.4</storyId>
    <title>Single Week Generation</title>
    <status>Draft</status>
    <generatedAt>2025-10-26</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>/home/snapiz/projects/github/timayz/imkitchen/docs/stories/story-7.4.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>meal planning system</asA>
    <iWant>generate a complete week's meal plan</iWant>
    <soThat>users receive 21 meal assignments (7 days × 3 courses) respecting all constraints</soThat>
    <tasks>
      <task id="1" status="pending">Implement single week generation function</task>
      <task id="2" status="pending">Generate 21 meal assignments (7 days × 3 courses)</task>
      <task id="3" status="pending">Implement appetizer rotation logic</task>
      <task id="4" status="pending">Implement main course selection</task>
      <task id="5" status="pending">Implement accompaniment pairing</task>
      <task id="6" status="pending">Implement dessert rotation logic</task>
      <task id="7" status="pending">Update RotationState throughout generation</task>
      <task id="8" status="pending">Construct WeekMealPlan result</task>
      <task id="9" status="pending">Write comprehensive unit tests</task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="1">Function generate_single_week implemented</criterion>
    <criterion id="2">Generates 21 assignments (7 days × 3 courses)</criterion>
    <criterion id="3">Assigns: appetizer, main (with optional accompaniment), dessert per day</criterion>
    <criterion id="4">Appetizer/dessert rotation (can repeat after exhausting full list)</criterion>
    <criterion id="5">Main course uses select_main_course_with_preferences</criterion>
    <criterion id="6">Accompaniment assigned if accepts_accompaniment=true</criterion>
    <criterion id="7">RotationState updated after each assignment (marks used recipes)</criterion>
    <criterion id="8">Returns WeekMealPlan with status=Future, is_locked=false</criterion>
    <criterion id="9">Unit tests cover full week generation</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>/home/snapiz/projects/github/timayz/imkitchen/docs/tech-spec-epic-7.md</path>
        <title>Technical Specification: Enhanced Meal Planning - Algorithm Implementation</title>
        <section>Section 3.4 - Single Week Generation</section>
        <snippet>
Function generate_single_week implemented:
- Signature: pub fn generate_single_week(recipes: Vec&lt;Recipe&gt;, preferences: &amp;UserPreferences, rotation_state: &amp;mut RotationState, week_start_date: Date) -&gt; Result&lt;WeekMealPlan, Error&gt;
- Generates 21 assignments (7 days × 3 courses)
- Assigns: appetizer, main (with optional accompaniment), dessert per day
- Appetizer/dessert rotation (can repeat after exhausting full list)
- Main course uses select_main_course_with_preferences
- Accompaniment assigned if accepts_accompaniment=true
- RotationState updated after each assignment
- Returns WeekMealPlan with status=Future, is_locked=false
        </snippet>
      </doc>
      <doc>
        <path>/home/snapiz/projects/github/timayz/imkitchen/docs/tech-spec-epic-7.md</path>
        <title>Technical Specification: Enhanced Meal Planning - Algorithm Implementation</title>
        <section>Section 3.1 - Data Models - WeekMealPlan</section>
        <snippet>
pub struct WeekMealPlan {
    id: String,                    // UUID
    user_id: UserId,
    start_date: Date,              // Monday
    end_date: Date,                // Sunday
    status: WeekStatus,            // Future | Current | Past | Archived
    is_locked: bool,
    generation_batch_id: String,   // UUID (links multi-week plans)
    meal_assignments: Vec&lt;MealAssignment&gt;,  // 21 items
    shopping_list_id: String,      // Generated in Story 7.6
    created_at: DateTime,
}
        </snippet>
      </doc>
      <doc>
        <path>/home/snapiz/projects/github/timayz/imkitchen/docs/tech-spec-epic-7.md</path>
        <title>Technical Specification: Enhanced Meal Planning - Algorithm Implementation</title>
        <section>Section 3.1 - Data Models - MealAssignment</section>
        <snippet>
pub struct MealAssignment {
    id: String,                    // UUID
    meal_plan_id: String,
    date: Date,
    course_type: CourseType,       // Appetizer | MainCourse | Dessert
    recipe_id: RecipeId,
    accompaniment_recipe_id: Option&lt;RecipeId&gt;,
    prep_required: bool,           // If recipe has advance prep
}
        </snippet>
      </doc>
      <doc>
        <path>/home/snapiz/projects/github/timayz/imkitchen/docs/tech-spec-epic-7.md</path>
        <title>Technical Specification: Enhanced Meal Planning - Algorithm Implementation</title>
        <section>Section 2.5 - Workflows - Week Generation Flow</section>
        <snippet>
Single Week Generation Flow:
1. Pre-filter recipes by dietary restrictions (Story 7.1)
2. Separate by type: appetizers, main_courses, desserts, accompaniments
3. Loop through 7 days (Mon-Sun):
   a. Select appetizer (cyclic rotation, reset if exhausted)
   b. Select main course (preference-aware, never repeat)
   c. Pair accompaniment if main accepts
   d. Select dessert (cyclic rotation, reset if exhausted)
   e. Update RotationState
4. Construct WeekMealPlan with 21 assignments
        </snippet>
      </doc>
      <doc>
        <path>/home/snapiz/projects/github/timayz/imkitchen/docs/tech-spec-epic-7.md</path>
        <title>Technical Specification: Enhanced Meal Planning - Algorithm Implementation</title>
        <section>Section 2.1 - Rotation Rules</section>
        <snippet>
Rotation Rules:
- Main Courses: NEVER repeat (uniqueness enforced across all weeks)
- Appetizers/Desserts: CAN repeat after exhausting full list (reset logic)
- Accompaniments: CAN repeat freely (not tracked)
        </snippet>
      </doc>
      <doc>
        <path>/home/snapiz/projects/github/timayz/imkitchen/docs/ux-specification.md</path>
        <title>imkitchen UX/UI Specification</title>
        <section>Section 9.2 - Meal Calendar Week View</section>
        <snippet>
Calendar Week View Component:
- Layout: 7 columns (days: Mon-Sun, always starting Monday), 3 rows per day (B/L/D)
- Week Convention: All weeks start on Monday. Week navigation moves forward/backward by 7 days from Monday.
- Week identifiers use Monday's date (e.g., "Week of Oct 14, 2025" for the week Monday Oct 14 - Sunday Oct 20).
        </snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/algorithm.rs</path>
        <kind>function</kind>
        <symbol>MealPlanningAlgorithm::generate</symbol>
        <lines>284-486</lines>
        <reason>Current algorithm implementation generates 21 meal assignments (7 days × 3 courses). Story 7.4 will extract single week generation into a dedicated function that can be called by multi-week generation. This function demonstrates the core constraint satisfaction logic, rotation state management, and scoring system that must be preserved.</reason>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/algorithm.rs</path>
        <kind>struct</kind>
        <symbol>RecipeForPlanning</symbol>
        <lines>8-20</lines>
        <reason>Data structure containing recipe metadata needed by the meal planning algorithm (recipe_type, complexity, prep times, dietary tags). Single week generation function will accept Vec&lt;RecipeForPlanning&gt; as input.</reason>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/algorithm.rs</path>
        <kind>struct</kind>
        <symbol>UserConstraints</symbol>
        <lines>23-36</lines>
        <reason>User profile constraints (weeknight_availability_minutes, dietary_restrictions) that affect recipe selection during week generation. Single week generation function will accept &amp;UserConstraints parameter.</reason>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/rotation.rs</path>
        <kind>struct</kind>
        <symbol>RotationState</symbol>
        <lines>67-86</lines>
        <reason>State tracking structure for recipe rotation management. Contains fields for tracking used main courses, appetizers, desserts, cuisine variety, and complex meal spacing. Single week generation must update this state after each assignment.</reason>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/rotation.rs</path>
        <kind>method</kind>
        <symbol>RotationState::mark_used_main_course</symbol>
        <lines>196-201</lines>
        <reason>Marks main course as used in rotation (never repeats). Single week generation must call this for each main course assigned.</reason>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/rotation.rs</path>
        <kind>method</kind>
        <symbol>RotationState::mark_used_appetizer</symbol>
        <lines>203-209</lines>
        <reason>Marks appetizer as used in rotation (can repeat after exhaustion). Single week generation must call this for each appetizer assigned.</reason>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/rotation.rs</path>
        <kind>method</kind>
        <symbol>RotationState::mark_used_dessert</symbol>
        <lines>211-217</lines>
        <reason>Marks dessert as used in rotation (can repeat after exhaustion). Single week generation must call this for each dessert assigned.</reason>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/rotation.rs</path>
        <kind>method</kind>
        <symbol>RotationState::reset_appetizers_if_all_used</symbol>
        <lines>234-250</lines>
        <reason>Resets appetizer tracking when all available appetizers exhausted. Single week generation should call this when selecting appetizers to enable cyclic rotation.</reason>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/rotation.rs</path>
        <kind>method</kind>
        <symbol>RotationState::reset_desserts_if_all_used</symbol>
        <lines>252-268</lines>
        <reason>Resets dessert tracking when all available desserts exhausted. Single week generation should call this when selecting desserts to enable cyclic rotation.</reason>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/rotation.rs</path>
        <kind>method</kind>
        <symbol>RotationState::increment_cuisine_usage</symbol>
        <lines>270-279</lines>
        <reason>Tracks cuisine variety across weeks. Single week generation should call this for each main course to enable cuisine diversity scoring in multi-week generation.</reason>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/rotation.rs</path>
        <kind>method</kind>
        <symbol>RotationState::update_last_complex_meal_date</symbol>
        <lines>289-298</lines>
        <reason>Tracks last complex meal date to avoid consecutive complex meals. Single week generation should update this when assigning complex recipes.</reason>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/events.rs</path>
        <kind>struct</kind>
        <symbol>WeekMealPlan</symbol>
        <lines>unknown</lines>
        <reason>Return type for single week generation function. Contains all metadata (id, user_id, start_date, end_date, status, is_locked, generation_batch_id) and 21 meal assignments.</reason>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/events.rs</path>
        <kind>struct</kind>
        <symbol>MealAssignment</symbol>
        <lines>unknown</lines>
        <reason>Individual meal assignment structure created for each of the 21 slots (7 days × 3 courses). Contains date, course_type, recipe_id, accompaniment_recipe_id, prep_required fields.</reason>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/error.rs</path>
        <kind>enum</kind>
        <symbol>MealPlanningError</symbol>
        <lines>4-60</lines>
        <reason>Error types that single week generation function must handle and return. Key errors: InsufficientRecipes (not enough recipes for week), InvalidDate (date parsing failures), NoCompatibleRecipes (no recipe meets constraints for specific day).</reason>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/lib.rs</path>
        <kind>function</kind>
        <symbol>calculate_next_week_start</symbol>
        <lines>51-65</lines>
        <reason>Utility function that calculates the next Monday date (week start). Single week generation uses this to validate week_start_date parameter is a Monday. All weeks must start on Monday per UX specification.</reason>
      </artifact>
    </code>
    <dependencies>
      <rust>
        <crate name="chrono" version="0.4+" purpose="Date/time handling for week calculations, Monday start dates, ISO 8601 formatting. Used for NaiveDate, Duration, Weekday operations." />
        <crate name="uuid" version="1.10+" purpose="Generate UUIDs for WeekMealPlan id, MealAssignment ids, generation_batch_id" />
        <crate name="serde" version="1.0+" purpose="Serialization for evento events and JSON storage of RotationState" />
        <crate name="bincode" version="2.0+" purpose="Binary encoding for evento event persistence" />
        <crate name="evento" version="1.5+" purpose="Event sourcing framework for emitting SingleWeekRegenerated events (future integration in Story 7.5)" />
        <crate name="thiserror" version="1.0+" purpose="Custom error type definitions (MealPlanningError enum)" />
      </rust>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint id="1" type="architecture">TDD enforced: Write tests first, implement to pass (cargo test, &gt;80% coverage via cargo-tarpaulin)</constraint>
    <constraint id="2" type="architecture">No external HTTP/IO in algorithm functions (pure business logic, dependency injection for data access)</constraint>
    <constraint id="3" type="pattern">Clean architecture: domain logic in crates/meal_planning/ with no HTTP dependencies</constraint>
    <constraint id="4" type="pattern">Event-sourced architecture: Algorithm returns data structures, route handlers emit events</constraint>
    <constraint id="5" type="business-rule">Main courses NEVER repeat across weeks (strict uniqueness constraint)</constraint>
    <constraint id="6" type="business-rule">Appetizers/Desserts CAN repeat after exhausting full list (cyclic rotation with reset)</constraint>
    <constraint id="7" type="business-rule">Accompaniments NOT tracked in rotation state (can repeat freely)</constraint>
    <constraint id="8" type="business-rule">All weeks start on Monday (ISO 8601 convention), week_start_date parameter must be Monday</constraint>
    <constraint id="9" type="business-rule">Week generation must produce exactly 21 assignments: 7 days (Mon-Sun) × 3 courses (Appetizer, MainCourse, Dessert)</constraint>
    <constraint id="10" type="performance">Single week generation must complete in &lt;1 second (P95 latency target)</constraint>
    <constraint id="11" type="data">WeekMealPlan.status must be set to Future for newly generated weeks</constraint>
    <constraint id="12" type="data">WeekMealPlan.is_locked must be false for newly generated weeks</constraint>
    <constraint id="13" type="error-handling">Return MealPlanningError::InsufficientRecipes if not enough recipes to generate week (minimum 7 main courses required)</constraint>
    <constraint id="14" type="error-handling">Return MealPlanningError::NoCompatibleRecipes if no main course meets constraints for specific day</constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>generate_single_week</name>
      <kind>function</kind>
      <signature>pub fn generate_single_week(recipes: Vec&lt;Recipe&gt;, preferences: &amp;UserPreferences, rotation_state: &amp;mut RotationState, week_start_date: Date) -&gt; Result&lt;WeekMealPlan, Error&gt;</signature>
      <path>crates/meal_planning/src/algorithm.rs</path>
      <description>Single week meal plan generation function. Generates 21 meal assignments (7 days × 3 courses) with constraint satisfaction and rotation tracking. This is the core function being implemented in Story 7.4.</description>
    </interface>
    <interface>
      <name>select_main_course_with_preferences</name>
      <kind>function</kind>
      <signature>pub fn select_main_course_with_preferences(available_main_courses: &amp;[Recipe], preferences: &amp;UserPreferences, rotation_state: &amp;RotationState, date: Date, day_of_week: DayOfWeek) -&gt; Option&lt;Recipe&gt;</signature>
      <path>crates/meal_planning/src/algorithm.rs</path>
      <description>Main course selection with preference-aware scoring (from Story 7.2). Single week generation calls this for each main course slot. Filters by time constraints, skill level, complexity avoidance, and scores by cuisine variety.</description>
    </interface>
    <interface>
      <name>select_accompaniment</name>
      <kind>function</kind>
      <signature>pub fn select_accompaniment(main_course: &amp;Recipe, available_accompaniments: &amp;[Recipe]) -&gt; Option&lt;Recipe&gt;</signature>
      <path>crates/meal_planning/src/algorithm.rs</path>
      <description>Accompaniment pairing logic (from Story 7.3). Single week generation calls this after assigning main course if main_course.accepts_accompaniment=true. Filters by preferred_accompaniments categories and selects randomly.</description>
    </interface>
    <interface>
      <name>filter_by_dietary_restrictions</name>
      <kind>function</kind>
      <signature>pub fn filter_by_dietary_restrictions(recipes: Vec&lt;Recipe&gt;, restrictions: &amp;[DietaryRestriction]) -&gt; Vec&lt;Recipe&gt;</signature>
      <path>crates/meal_planning/src/dietary_filter.rs</path>
      <description>Dietary restriction filtering (from Story 7.1). Single week generation should pre-filter recipes before separating by type to exclude incompatible recipes early.</description>
    </interface>
    <interface>
      <name>RotationState::mark_used_main_course</name>
      <kind>method</kind>
      <signature>pub fn mark_used_main_course(&amp;mut self, recipe_id: &amp;str)</signature>
      <path>crates/meal_planning/src/rotation.rs</path>
      <description>Marks main course as used (never repeats). Call after assigning each main course in week generation.</description>
    </interface>
    <interface>
      <name>RotationState::mark_used_appetizer</name>
      <kind>method</kind>
      <signature>pub fn mark_used_appetizer(&amp;mut self, recipe_id: &amp;str)</signature>
      <path>crates/meal_planning/src/rotation.rs</path>
      <description>Marks appetizer as used (can repeat after exhaustion). Call after assigning each appetizer in week generation.</description>
    </interface>
    <interface>
      <name>RotationState::mark_used_dessert</name>
      <kind>method</kind>
      <signature>pub fn mark_used_dessert(&amp;mut self, recipe_id: &amp;str)</signature>
      <path>crates/meal_planning/src/rotation.rs</path>
      <description>Marks dessert as used (can repeat after exhaustion). Call after assigning each dessert in week generation.</description>
    </interface>
    <interface>
      <name>RotationState::reset_appetizers_if_all_used</name>
      <kind>method</kind>
      <signature>pub fn reset_appetizers_if_all_used(&amp;mut self, available_count: usize)</signature>
      <path>crates/meal_planning/src/rotation.rs</path>
      <description>Resets appetizer tracking when all exhausted. Call when selecting appetizers to enable cyclic rotation.</description>
    </interface>
    <interface>
      <name>RotationState::reset_desserts_if_all_used</name>
      <kind>method</kind>
      <signature>pub fn reset_desserts_if_all_used(&amp;mut self, available_count: usize)</signature>
      <path>crates/meal_planning/src/rotation.rs</path>
      <description>Resets dessert tracking when all exhausted. Call when selecting desserts to enable cyclic rotation.</description>
    </interface>
    <interface>
      <name>RotationState::increment_cuisine_usage</name>
      <kind>method</kind>
      <signature>pub fn increment_cuisine_usage(&amp;mut self, cuisine: &amp;Cuisine)</signature>
      <path>crates/meal_planning/src/rotation.rs</path>
      <description>Tracks cuisine variety. Call for each main course assigned to enable cuisine diversity scoring.</description>
    </interface>
    <interface>
      <name>RotationState::update_last_complex_meal_date</name>
      <kind>method</kind>
      <signature>pub fn update_last_complex_meal_date(&amp;mut self, date: &amp;str)</signature>
      <path>crates/meal_planning/src/rotation.rs</path>
      <description>Tracks last complex meal date. Call when assigning complex recipes to avoid consecutive complex meals.</description>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Testing standards for Story 7.4:
      - Framework: Built-in Rust #[test] with assert macros
      - TDD enforced: Write tests first before implementation
      - Unit tests for single week generation function with varying recipe counts
      - Test appetizer/dessert cyclic rotation and reset logic
      - Test main course uniqueness (no repeats within week)
      - Test accompaniment pairing when main course accepts_accompaniment=true
      - Test RotationState mutations after each assignment
      - Test WeekMealPlan structure validation (status=Future, is_locked=false, 21 assignments)
      - Test error cases: insufficient main courses, no compatible recipes for day
      - Integration tests: Full week generation with realistic recipe data
      - Performance test: Verify &lt;1 second generation time
      - Coverage target: &gt;80% for algorithm.rs functions (measured via cargo-tarpaulin)
    </standards>
    <locations>
      <location>crates/meal_planning/src/algorithm.rs</location>
      <location>crates/meal_planning/tests/unit/</location>
      <location>crates/meal_planning/tests/integration/</location>
    </locations>
    <ideas>
      <idea ac="1,2,3">Test generate_single_week returns 21 assignments (7 days × 3 courses) with correct structure</idea>
      <idea ac="2">Test each day has exactly 3 assignments: one Appetizer, one MainCourse, one Dessert</idea>
      <idea ac="3">Test dates span Monday-Sunday (7 consecutive days) starting from week_start_date</idea>
      <idea ac="4">Test appetizer rotation: Exhaust 5 appetizers, verify cycles back to first after reset</idea>
      <idea ac="4">Test dessert rotation: Exhaust 8 desserts, verify cycles back to first after reset</idea>
      <idea ac="4">Test reset logic: reset_appetizers_if_all_used called when all appetizers used</idea>
      <idea ac="4">Test reset logic: reset_desserts_if_all_used called when all desserts used</idea>
      <idea ac="5">Test main course selection uses select_main_course_with_preferences for each day</idea>
      <idea ac="5">Test main courses never repeat within single week (uniqueness constraint)</idea>
      <idea ac="6">Test accompaniment assigned when main course accepts_accompaniment=true</idea>
      <idea ac="6">Test accompaniment_recipe_id=None when main course accepts_accompaniment=false</idea>
      <idea ac="6">Test select_accompaniment called for compatible main courses</idea>
      <idea ac="7">Test RotationState.mark_used_main_course called for each main course</idea>
      <idea ac="7">Test RotationState.mark_used_appetizer called for each appetizer</idea>
      <idea ac="7">Test RotationState.mark_used_dessert called for each dessert</idea>
      <idea ac="7">Test RotationState updated correctly after week generation (verify state mutations)</idea>
      <idea ac="8">Test WeekMealPlan.status=Future for newly generated week</idea>
      <idea ac="8">Test WeekMealPlan.is_locked=false for newly generated week</idea>
      <idea ac="8">Test WeekMealPlan.start_date is Monday, end_date is Sunday</idea>
      <idea ac="8">Test WeekMealPlan.generation_batch_id is unique UUID</idea>
      <idea ac="9">Test error case: Insufficient main courses (less than 7) returns InsufficientRecipes error</idea>
      <idea ac="9">Test error case: No compatible main course for specific day returns NoCompatibleRecipes error</idea>
      <idea ac="9">Test edge case: Exactly 7 main courses generates week successfully</idea>
      <idea ac="9">Test edge case: week_start_date not Monday returns InvalidWeekStart error</idea>
      <idea ac="9">Performance test: Verify generation completes in &lt;1 second with 50 recipes</idea>
    </ideas>
  </tests>
</story-context>
