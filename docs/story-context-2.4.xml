<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>4</storyId>
    <title>Organize Recipes into Collections</title>
    <status>Draft</status>
    <generatedAt>2025-10-14</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>/home/snapiz/projects/github/timayz/imkitchen/docs/stories/story-2.4.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>user with multiple recipes</asA>
    <iWant>to organize them into collections</iWant>
    <soThat>I can find related recipes easily</soThat>
    <tasks>
      - Create Collection aggregate and domain model (AC: 1, 2, 8)
      - Create read model tables for collections (AC: 1, 3, 4)
      - Implement evento subscription handlers (AC: 1, 3)
      - Create collections management page (AC: 1, 2, 8)
      - Implement collection CRUD routes (AC: 2, 8)
      - Implement recipe-collection assignment routes (AC: 3, 4)
      - Add collection sidebar filtering to recipe library (AC: 5, 6, 7)
      - Add collection assignment UI on recipe detail page (AC: 3, 4)
      - Write unit tests for Collection aggregate (TDD)
      - Write integration tests for collection CRUD (TDD)
      - Write E2E tests for collection management flow (TDD)
    </tasks>
  </story>

  <acceptanceCriteria>
    1. Collections management page displays all user collections
    2. User can create new collection with name and optional description
    3. User can add/remove recipes to/from collections
    4. Recipe can belong to multiple collections
    5. Collections displayed in recipe library sidebar for filtering
    6. Clicking collection filters recipe list to show only that collection
    7. Default "All Recipes" view shows uncategorized and all collections
    8. Collections deletable (removes collection but not recipes)
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/solution-architecture.md</path>
        <title>Solution Architecture Document</title>
        <section>3.2 Data Models and Relationships (lines 271-382)</section>
        <snippet>Event-sourced aggregates with evento, CQRS read model projections, many-to-many relationships via junction tables</snippet>
        <reason>Defines event sourcing pattern, aggregate structure, and read model projection strategy for collection management</reason>
      </doc>
      <doc>
        <path>docs/solution-architecture.md</path>
        <title>Solution Architecture Document</title>
        <section>11.1 Domain Crate Structure (lines 1374-1443)</section>
        <snippet>Domain crates organized by bounded context: crates/recipe/ with aggregate.rs, commands.rs, events.rs, read_model.rs</snippet>
        <reason>Establishes file structure and organization for Collection aggregate within recipe crate</reason>
      </doc>
      <doc>
        <path>docs/solution-architecture.md</path>
        <title>Solution Architecture Document</title>
        <section>2.3 Page Routing and Navigation (lines 143-200)</section>
        <snippet>Route structure: POST/PUT/DELETE for mutations, TwinSpark progressive enhancement, authentication middleware</snippet>
        <reason>Defines routing conventions for collection CRUD endpoints and recipe assignment operations</reason>
      </doc>
      <doc>
        <path>docs/solution-architecture.md</path>
        <title>Solution Architecture Document</title>
        <section>7.1 Component Structure (lines 752-819)</section>
        <snippet>Askama template hierarchy: base.html, components/, pages/, partials/. Server-side rendering with type safety</snippet>
        <reason>Guides template creation for collections management page and sidebar filtering UI</reason>
      </doc>
      <doc>
        <path>docs/solution-architecture.md</path>
        <title>Solution Architecture Document</title>
        <section>15 Testing Strategy (lines 1951-2066)</section>
        <snippet>TDD enforced: unit tests for domain logic, integration tests for HTTP routes, E2E tests for user flows. 80% coverage goal</snippet>
        <reason>Establishes testing requirements and patterns for collection feature implementation</reason>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-2.md</path>
        <title>Technical Specification: Recipe Management System</title>
        <section>Collection Management (lines 120-160)</section>
        <snippet>Collection aggregate with CollectionCreated/Deleted events, many-to-many recipe_collection_assignments table, ownership verification</snippet>
        <reason>Provides detailed technical specification for collection domain implementation</reason>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic Breakdown</title>
        <section>Story 2.4: Organize Recipes into Collections (lines 334-357)</section>
        <snippet>Acceptance criteria, prerequisites, technical notes for collection organization feature</snippet>
        <reason>Source of truth for story requirements and success criteria</reason>
      </doc>
      <doc>
        <path>docs/stories/story-2.3.md</path>
        <title>Story 2.3: Delete Recipe (Completed)</title>
        <section>Dev Notes - Lessons Learned</section>
        <snippet>Use POST method for mutations, TwinSpark pattern with ts-location header, structured logging, TDD approach, soft delete pattern</snippet>
        <reason>Provides implementation patterns and lessons from previous story to apply to collection feature</reason>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>crates/recipe/src/aggregate.rs</path>
        <kind>aggregate</kind>
        <symbol>RecipeAggregate</symbol>
        <lines>8-100</lines>
        <reason>Reference implementation for evento aggregate pattern with event handlers (recipe_created, recipe_deleted, recipe_favorited)</reason>
      </artifact>
      <artifact>
        <path>crates/recipe/src/events.rs</path>
        <kind>events</kind>
        <symbol>RecipeCreated, RecipeDeleted, RecipeFavorited, RecipeUpdated</symbol>
        <lines>1-50</lines>
        <reason>Pattern for defining evento events with bincode serialization for CollectionCreated, RecipeAddedToCollection events</reason>
      </artifact>
      <artifact>
        <path>crates/recipe/src/commands.rs</path>
        <kind>commands</kind>
        <symbol>CreateRecipeCommand, UpdateRecipeCommand, DeleteRecipeCommand</symbol>
        <lines>1-100</lines>
        <reason>Command handler pattern with validation, ownership verification, and evento event emission for collection commands</reason>
      </artifact>
      <artifact>
        <path>crates/recipe/src/read_model.rs</path>
        <kind>read_model</kind>
        <symbol>evento subscription handlers, projection logic</symbol>
        <lines>1-150</lines>
        <reason>Pattern for implementing evento subscriptions to project events into read model tables (recipe_collections, recipe_collection_assignments)</reason>
      </artifact>
      <artifact>
        <path>src/routes/recipes.rs</path>
        <kind>routes</kind>
        <symbol>post_create_recipe, post_update_recipe, post_delete_recipe, post_favorite_recipe</symbol>
        <lines>1-700</lines>
        <reason>Reference implementation for HTTP route handlers with auth middleware, ownership checks, TwinSpark responses, structured logging</reason>
      </artifact>
      <artifact>
        <path>migrations/01_v0.2_recipes.sql</path>
        <kind>migration</kind>
        <symbol>recipes table schema</symbol>
        <lines>1-28</lines>
        <reason>Database migration pattern for creating read model tables with indexes, foreign keys, and proper SQLite types</reason>
      </artifact>
      <artifact>
        <path>templates/pages/recipe-detail.html</path>
        <kind>template</kind>
        <symbol>recipe detail page with owner actions</symbol>
        <lines>N/A</lines>
        <reason>Location to add collection assignment UI with checkboxes and TwinSpark AJAX updates</reason>
      </artifact>
      <artifact>
        <path>templates/pages/recipe-list.html</path>
        <kind>template</kind>
        <symbol>recipe library page</symbol>
        <lines>N/A</lines>
        <reason>Location to add sidebar with collection filtering UI</reason>
      </artifact>
    </code>
    <dependencies>
      <rust>
        <package name="evento" version="1.3" features="sqlite-migrator">Event sourcing framework for aggregates, events, and subscriptions</package>
        <package name="axum" version="0.8" features="macros">HTTP server framework for route handlers</package>
        <package name="askama" version="0.14">Type-safe template engine for HTML rendering</package>
        <package name="sqlx" version="0.8" features="runtime-tokio,sqlite,chrono,uuid">Async SQL toolkit for read model queries and migrations</package>
        <package name="validator" version="0.20" features="derive">Input validation for collection name and description fields</package>
        <package name="serde" version="1.0" features="derive">Serialization for aggregate state and event payloads</package>
        <package name="bincode" version="2.0">Binary encoding for evento event serialization</package>
        <package name="chrono" version="0.4" features="serde">Timestamp handling for created_at and assigned_at fields</package>
        <package name="uuid" version="1.10" features="v4,serde">Unique identifier generation for collection IDs</package>
        <package name="thiserror" version="1.0">Custom error type definitions for RecipeError and CollectionError</package>
        <package name="anyhow" version="1.0">Error handling in async functions</package>
        <package name="tracing" version="0.1">Structured logging for collection operations</package>
      </rust>
    </dependencies>
  </artifacts>

  <constraints>
    - MUST use evento event sourcing framework with CollectionAggregate and bincode-encoded events
    - MUST implement CQRS pattern: commands write events, queries read from materialized read models
    - MUST use POST method for all mutations (not PUT/DELETE HTTP verbs) per TwinSpark pattern
    - MUST verify ownership: user can only create/delete own collections and assign own recipes
    - MUST implement soft delete for collections (deleted_at timestamp, preserve event history)
    - MUST use many-to-many relationship via recipe_collection_assignments table (recipe can belong to multiple collections)
    - MUST implement evento subscriptions to project events into read model tables
    - MUST use Askama templates for server-side rendering with type-safe compilation
    - MUST apply TwinSpark progressive enhancement: ts-req attributes, ts-location headers, AJAX updates
    - MUST implement structured logging with tracing: include user_id, collection_id, recipe_id, event, action fields
    - MUST follow TDD: write tests before implementation, achieve 80% code coverage
    - MUST use validator crate for input validation: collection name (min 3, max 100 chars)
    - MUST handle errors gracefully: 403 Forbidden for unauthorized access, 404 NotFound, 422 validation errors
    - MUST maintain audit trail: all collection operations captured as immutable events in event store
    - MUST create database migration for recipe_collections and recipe_collection_assignments tables with indexes
  </constraints>

  <interfaces>
    <interface>
      <name>evento::create</name>
      <kind>function</kind>
      <signature>evento::create::&lt;CollectionAggregate&gt;().data(&amp;CollectionCreated { ... }).metadata(&amp;user_id).commit(&amp;executor).await</signature>
      <path>evento crate</path>
      <reason>Create new Collection aggregate with CollectionCreated event</reason>
    </interface>
    <interface>
      <name>evento::get</name>
      <kind>function</kind>
      <signature>evento::get::&lt;CollectionAggregate&gt;(&amp;collection_id, &amp;executor).await</signature>
      <path>evento crate</path>
      <reason>Load Collection aggregate from event stream for ownership verification</reason>
    </interface>
    <interface>
      <name>evento::update</name>
      <kind>function</kind>
      <signature>evento::update::&lt;CollectionAggregate&gt;(&amp;collection_id).data(&amp;CollectionDeleted { ... }).commit(&amp;executor).await</signature>
      <path>evento crate</path>
      <reason>Apply CollectionDeleted or RecipeAddedToCollection events to existing aggregate</reason>
    </interface>
    <interface>
      <name>evento::handler</name>
      <kind>macro</kind>
      <signature>#[evento::handler(CollectionAggregate)] async fn collection_created_handler(&amp;context, event)</signature>
      <path>evento crate</path>
      <reason>Define evento subscription handlers to project events into read model tables</reason>
    </interface>
    <interface>
      <name>sqlx::query!</name>
      <kind>macro</kind>
      <signature>sqlx::query!("INSERT INTO recipe_collections (id, user_id, name, description, created_at) VALUES (?, ?, ?, ?, ?)", ...)</signature>
      <path>sqlx crate</path>
      <reason>Execute SQL queries in subscription handlers to update read model tables</reason>
    </interface>
    <interface>
      <name>Validate trait</name>
      <kind>trait</kind>
      <signature>#[derive(Validate)] struct CreateCollectionCommand { #[validate(length(min=3, max=100))] name: String }</signature>
      <path>validator crate</path>
      <reason>Input validation for collection name and description fields</reason>
    </interface>
    <interface>
      <name>axum::Router</name>
      <kind>struct</kind>
      <signature>Router::new().route("/collections", post(create_collection)).route("/collections/:id", delete(delete_collection))</signature>
      <path>axum crate</path>
      <reason>Register collection CRUD routes in Axum HTTP server</reason>
    </interface>
    <interface>
      <name>Auth extractor</name>
      <kind>extractor</kind>
      <signature>Extension&lt;Auth&gt; - contains user_id from JWT</signature>
      <path>src/middleware/auth.rs</path>
      <reason>Extract authenticated user ID for ownership verification in route handlers</reason>
    </interface>
    <interface>
      <name>askama::Template</name>
      <kind>trait</kind>
      <signature>#[derive(Template)] #[template(path = "pages/collections.html")] struct CollectionsTemplate { ... }</signature>
      <path>askama crate</path>
      <reason>Define type-safe templates for collections management page with compile-time checking</reason>
    </interface>
  </interfaces>

  <tests>
    <standards>
      TDD enforced: write tests BEFORE implementation. Use cargo test for unit/integration tests, Playwright for E2E.

      Unit Tests: Test aggregate event handlers, command validation, ownership checks. Location: crates/recipe/tests/collection_tests.rs. Framework: Rust standard test framework with #[test] attribute.

      Integration Tests: Test HTTP routes, read model sync, database queries. Location: tests/collection_integration_tests.rs. Use in-memory SQLite for fast, deterministic tests.

      E2E Tests: Test complete user flows with browser automation. Location: e2e/tests/recipe-management.spec.ts. Framework: Playwright with TypeScript.

      Coverage Goal: 80% minimum. Use cargo-tarpaulin for coverage reporting.

      Patterns: Arrange-Act-Assert (AAA), test names describe behavior (test_collection_created_event_sets_name), fixtures for test data (setup_test_db, insert_test_user, insert_test_recipe).
    </standards>

    <locations>
      - crates/recipe/tests/collection_tests.rs (unit tests for Collection aggregate)
      - tests/collection_integration_tests.rs (integration tests for collection CRUD routes)
      - e2e/tests/recipe-management.spec.ts (E2E tests for collection management flow - extend existing file)
    </locations>

    <ideas>
      AC-1: Test GET /collections displays all user collections with recipe counts
      AC-2: Test POST /collections creates collection with valid name/description, validates min/max length
      AC-3: Test POST /collections/:id/recipes/:recipe_id adds recipe to collection, DELETE removes it
      AC-4: Test recipe appears in multiple collections via repeated assignment operations
      AC-5: Test collections sidebar renders with correct recipe counts per collection
      AC-6: Test clicking collection filters recipe list to show only recipes in that collection (URL param ?collection=:id)
      AC-7: Test "All Recipes" view shows union of all non-deleted recipes (uncategorized + all collections)
      AC-8: Test DELETE /collections/:id soft deletes collection, removes assignments, preserves recipes

      Unit Tests:
      - test_collection_created_event_sets_name_and_description
      - test_collection_name_validation_min_length_3_chars
      - test_collection_name_validation_max_length_100_chars
      - test_ownership_verification_prevents_unauthorized_deletion
      - test_recipe_added_to_collection_event_creates_assignment
      - test_recipe_removed_from_collection_event_deletes_assignment
      - test_collection_deletion_preserves_recipes

      Integration Tests:
      - test_create_collection_syncs_to_read_model
      - test_delete_collection_removes_assignments_but_not_recipes
      - test_add_recipe_to_collection_creates_assignment
      - test_remove_recipe_from_collection_deletes_assignment
      - test_unauthorized_collection_access_returns_403
      - test_recipe_belongs_to_multiple_collections
      - test_filter_recipes_by_collection_id

      E2E Tests:
      - test_user_creates_collection_adds_recipes_views_filtered_list
      - test_recipe_appears_in_multiple_collections
      - test_deleting_collection_does_not_delete_recipes
      - test_sidebar_filtering_shows_correct_recipes_per_collection
    </ideas>
  </tests>
</story-context>
