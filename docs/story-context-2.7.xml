<story-context id="bmad/bmm/workflows/4-implementation/story-context/story-2.7" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>7</storyId>
    <title>Share Recipe to Community</title>
    <status>Ready</status>
    <generatedAt>2025-10-15</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>/home/snapiz/projects/github/timayz/imkitchen/docs/stories/story-2.7.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>recipe owner</asA>
    <iWant>to share my recipe with the community</iWant>
    <soThat>others can discover and use it</soThat>
    <tasks>
      - Implement ShareRecipe command and event (AC: 1, 2, 6)
      - Update read model for share status (AC: 3, 9, 12)
      - Add share toggle UI to recipe edit page (AC: 1)
      - Implement share toggle route (AC: 2, 6)
      - Community discovery feed filtering (AC: 3, 10, 12)
      - Recipe attribution display (AC: 4)
      - Ownership enforcement for editing (AC: 5)
      - Profile shared recipe count (AC: 8)
      - Ratings visibility (AC: 7)
      - Write unit tests for share command (TDD)
      - Write integration tests for share toggle (TDD)
    </tasks>
  </story>

  <acceptanceCriteria>
    1. "Share to Community" toggle visible on recipe edit page
    2. Toggle changes privacy from "private" to "shared" (RecipeShared event)
    3. Shared recipes appear in community discovery feed (/discover route)
    4. Recipe attribution displays creator's username on community pages
    5. Shared recipes remain editable only by owner
    6. Owner can revert to private at any time (removes from community discovery)
    7. Ratings and reviews visible only on shared recipes
    8. User profile shows count of shared recipes
    9. New recipes default to private (is_shared = false)
    10. Direct URL to private recipe returns 404 for non-owners
    11. Shared recipes excluded from owner's personal recipe limit enforcement
    12. Community feed filters shared recipes (is_shared = true AND deleted_at IS NULL)
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>/home/snapiz/projects/github/timayz/imkitchen/docs/epics.md</path>
        <title>Epic 2: Recipe Management System - Story 2.7</title>
        <section>Story 2.7: Share Recipe to Community</section>
        <snippet>Recipe owner wants to share recipe with community for discovery. Includes privacy toggle, community feed visibility, creator attribution, and ownership controls.</snippet>
        <relevance>Source of acceptance criteria and business requirements</relevance>
      </doc>
      <doc>
        <path>/home/snapiz/projects/github/timayz/imkitchen/docs/tech-spec-epic-2.md</path>
        <title>Technical Specification: Recipe Management System</title>
        <section>Privacy and Sharing Controls (lines 1691-1702)</section>
        <snippet>Default is_shared = false on creation. Explicit opt-in via "Share to Community" toggle. RecipeShared event with shared boolean. Direct URL to private recipe returns 404 if not owner.</snippet>
        <relevance>Technical implementation details for sharing feature</relevance>
      </doc>
      <doc>
        <path>/home/snapiz/projects/github/timayz/imkitchen/docs/tech-spec-epic-2.md</path>
        <title>Share Recipe Command Implementation</title>
        <section>Command Handlers (lines 513-530)</section>
        <snippet>share_recipe command: Load recipe aggregate, verify ownership (recipe.user_id == auth_user.id), emit RecipeShared event with shared boolean parameter. Single command handles both share and unshare.</snippet>
        <relevance>Exact command implementation pattern to follow</relevance>
      </doc>
      <doc>
        <path>/home/snapiz/projects/github/timayz/imkitchen/docs/tech-spec-epic-2.md</path>
        <title>Community Discovery Workflow</title>
        <section>Community Discovery (lines 1537-1581)</section>
        <snippet>Public route GET /discover (no auth required). Filter: WHERE is_shared = TRUE AND deleted_at IS NULL. Join with users table for creator attribution. Pagination: 20 recipes per page. SEO optimization with Open Graph and Schema.org markup.</snippet>
        <relevance>Community feed query and filtering logic</relevance>
      </doc>
      <doc>
        <path>/home/snapiz/projects/github/timayz/imkitchen/docs/tech-spec-epic-2.md</path>
        <title>Database Schema - Recipes Table</title>
        <section>Database Schema (lines 991-1006)</section>
        <snippet>recipes table has is_shared BOOLEAN DEFAULT FALSE. Index: idx_recipes_shared ON recipes(is_shared) WHERE is_shared = TRUE. Read model projection via event subscription handler project_recipe_shared.</snippet>
        <relevance>Database schema and indexing requirements</relevance>
      </doc>
      <doc>
        <path>/home/snapiz/projects/github/timayz/imkitchen/docs/solution-architecture.md</path>
        <title>Event Sourcing Pattern with evento</title>
        <section>Data Models and Relationships (lines 383-442)</section>
        <snippet>All state changes captured as immutable events. Events stored in evento event store with aggregator pattern. Read models materialized via async subscriptions for query optimization.</snippet>
        <relevance>Architectural foundation for RecipeShared event</relevance>
      </doc>
      <doc>
        <path>/home/snapiz/projects/github/timayz/imkitchen/docs/solution-architecture.md</path>
        <title>CQRS Read Model Projections</title>
        <section>Data Models and Relationships (lines 422-462)</section>
        <snippet>Command side: evento aggregates handle business logic and emit events. Query side: read models (SQLite tables) updated via async subscription handlers. Projections ensure eventual consistency.</snippet>
        <relevance>Read model projection pattern for is_shared status</relevance>
      </doc>
    </docs>

    <code>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/recipe/src/aggregate.rs</path>
        <kind>aggregate</kind>
        <symbol>RecipeAggregate</symbol>
        <lines>1-100</lines>
        <reason>Core recipe aggregate structure. Need to verify is_shared field exists and add recipe_shared event handler if missing.</reason>
        <note>Currently has: recipe_id, user_id, title, ingredients, instructions, prep_time_min, cook_time_min, advance_prep_hours, serving_size, is_favorite, is_deleted, tags, created_at. Missing: is_shared field.</note>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/recipe/src/events.rs</path>
        <kind>events</kind>
        <symbol>RecipeCreated, RecipeDeleted, RecipeFavorited, RecipeUpdated, RecipeTagged</symbol>
        <lines>1-97</lines>
        <reason>Event definitions for recipe domain. Need to add RecipeShared event with shared boolean field.</reason>
        <note>Pattern to follow: AggregatorName derive macro, Encode/Decode/Serialize/Deserialize derives, user_id metadata field, timestamp field.</note>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/recipe/src/commands.rs</path>
        <kind>commands</kind>
        <symbol>create_recipe, favorite_recipe</symbol>
        <lines>1-100</lines>
        <reason>Command handlers for recipe domain. Use favorite_recipe as reference pattern for implementing share_recipe command with ownership verification.</reason>
        <note>Pattern: validate inputs, check ownership/permissions, load aggregate from evento, emit event via evento::update(), commit to executor.</note>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/crates/recipe/src/read_model.rs</path>
        <kind>read_model</kind>
        <symbol>RecipeReadModel, recipe_created_handler, recipe_favorited_handler</symbol>
        <lines>1-150</lines>
        <reason>Read model projection handlers. RecipeReadModel already has is_shared field (line 26). Need to add recipe_shared_handler following recipe_favorited_handler pattern.</reason>
        <note>Handler pattern: #[evento::handler(RecipeAggregate)] async fn, extract SqlitePool from context, execute UPDATE query with event data.</note>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/migrations/01_v0.2_recipes.sql</path>
        <kind>migration</kind>
        <symbol>recipes table schema</symbol>
        <lines>6-28</lines>
        <reason>Database schema for recipes read model. Confirms is_shared INTEGER DEFAULT 0 column exists (line 17). Index idx_recipes_shared already created (line 27).</reason>
        <note>Schema ready for story - no migration needed. is_shared defaults to 0 (false/private) per AC-9.</note>
      </artifact>
      <artifact>
        <path>/home/snapiz/projects/github/timayz/imkitchen/src/routes/recipes.rs</path>
        <kind>route_handler</kind>
        <symbol>post_favorite_recipe</symbol>
        <lines>992-1003</lines>
        <reason>Reference pattern for implementing post_share_recipe route handler. Shows TwinSpark pattern, ownership verification, command invocation, and HTML fragment response.</reason>
        <note>Follow same pattern: State + Extension(Auth) + Path params, create command struct, call domain command, return template response or error.</note>
      </artifact>
    </code>

    <dependencies>
      <rust>
        <crate name="evento" version="1.4" features="sqlite-migrator">Event sourcing framework - core dependency for RecipeShared event and subscription handlers</crate>
        <crate name="sqlx" version="0.8" features="runtime-tokio, sqlite, chrono, uuid">Database access for read model queries and projections</crate>
        <crate name="axum" version="0.8" features="macros">HTTP routing and handlers for share toggle endpoint</crate>
        <crate name="askama" version="0.14">Template rendering for HTML responses (recipe edit page, community feed)</crate>
        <crate name="serde" version="1.0" features="derive">Serialization for events and command structs</crate>
        <crate name="bincode" version="2.0">Event serialization format for evento</crate>
        <crate name="tracing" version="0.1">Structured logging for share operations</crate>
        <crate name="chrono" version="0.4" features="serde">Timestamp handling for events</crate>
        <crate name="validator" version="0.20" features="derive">Input validation for share command</crate>
        <crate name="anyhow" version="1.0">Error handling</crate>
      </rust>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint>
      <rule>Event Sourcing with evento</rule>
      <description>All state changes must be captured as immutable events (RecipeShared) emitted via evento::update(). Aggregates rebuilt from event stream. No direct database updates to aggregate state.</description>
      <source>docs/solution-architecture.md#3.2, ADR-001</source>
    </constraint>
    <constraint>
      <rule>CQRS Read Model Pattern</rule>
      <description>Commands write events to evento event store. Queries read from denormalized SQLite read model tables. Async subscription handlers project events to read model. Eventual consistency model.</description>
      <source>docs/solution-architecture.md#3.2, lines 422-462</source>
    </constraint>
    <constraint>
      <rule>Ownership Verification Required</rule>
      <description>All recipe mutations (share, edit, delete) must verify ownership: recipe.user_id == auth_user.id. Return PermissionDenied error if ownership check fails. Community users cannot edit shared recipes.</description>
      <source>docs/tech-spec-epic-2.md#Security, lines 2084-2089</source>
    </constraint>
    <constraint>
      <rule>Privacy-First Design</rule>
      <description>Recipes default to private (is_shared = false). Sharing requires explicit opt-in via user action. Private recipes excluded from /discover queries. Direct URL access to private recipes returns 404 for non-owners.</description>
      <source>docs/tech-spec-epic-2.md#Privacy Controls, lines 1691-1702</source>
    </constraint>
    <constraint>
      <rule>TDD Enforced</rule>
      <description>Write tests before implementation. Unit tests for command logic and event handlers. Integration tests for end-to-end flows with read model projection. Use evento::unsafe_oneshot for synchronous projections in tests.</description>
      <source>docs/solution-architecture.md#15 Testing Strategy, Story 2.6 completion notes</source>
    </constraint>
    <constraint>
      <rule>Structured Logging</rule>
      <description>Use tracing::instrument on handlers. Log user_id, recipe_id, and shared status on share operations. Log errors with context for debugging.</description>
      <source>Story 2.6 lessons learned, docs/solution-architecture.md#Observability</source>
    </constraint>
    <constraint>
      <rule>Index-Backed Queries</rule>
      <description>Community discovery queries must use idx_recipes_shared index. Filter: WHERE is_shared = 1 AND deleted_at IS NULL. Pagination required (20 per page).</description>
      <source>docs/tech-spec-epic-2.md#Performance, lines 1630-1636</source>
    </constraint>
  </constraints>

  <interfaces>
    <interface>
      <name>evento::update</name>
      <kind>function</kind>
      <signature>evento::update::&lt;RecipeAggregate&gt;(aggregator_id: &str) -> UpdateBuilder</signature>
      <path>evento crate (external)</path>
      <usage>Emit RecipeShared event: evento::update::&lt;RecipeAggregate&gt;(&recipe_id).data(&RecipeShared { shared }).metadata(&user_id)?.commit(executor).await?</usage>
      <note>Core evento API for event sourcing. Returns UpdateBuilder for chaining data/metadata/commit calls.</note>
    </interface>
    <interface>
      <name>evento::get</name>
      <kind>function</kind>
      <signature>evento::get::&lt;RecipeAggregate&gt;(aggregator_id: &str, executor: &Executor) -> Result&lt;RecipeAggregate&gt;</signature>
      <path>evento crate (external)</path>
      <usage>Load recipe aggregate to verify ownership: let recipe = evento::get::&lt;RecipeAggregate&gt;(&recipe_id, executor).await?; if recipe.user_id != user_id { return Err(PermissionDenied) }</usage>
      <note>Rebuilds aggregate state from event stream. Use for ownership checks before mutations.</note>
    </interface>
    <interface>
      <name>#[evento::handler(RecipeAggregate)]</name>
      <kind>macro</kind>
      <signature>#[evento::handler(RecipeAggregate)] async fn handler_name&lt;E: Executor&gt;(context: &Context&lt;'_, E&gt;, event: EventDetails&lt;EventType&gt;) -> anyhow::Result&lt;()&gt;</signature>
      <path>evento crate (external)</path>
      <usage>Define recipe_shared_handler to project RecipeShared events to read model. Extract SqlitePool from context, execute UPDATE query.</usage>
      <note>Must be registered in subscription builder in main.rs. Handler runs asynchronously on event commit.</note>
    </interface>
    <interface>
      <name>query_recipe_by_id</name>
      <kind>function</kind>
      <signature>pub async fn query_recipe_by_id(recipe_id: &str, pool: &SqlitePool) -> RecipeResult&lt;RecipeReadModel&gt;</signature>
      <path>crates/recipe/src/read_model.rs</path>
      <usage>Fetch recipe from read model for display. Check is_shared field to determine visibility. Return 404 if private and user is not owner.</usage>
      <note>Already implemented. No changes needed for this story.</note>
    </interface>
    <interface>
      <name>query_recipes_by_user</name>
      <kind>function</kind>
      <signature>pub async fn query_recipes_by_user(user_id: &str, favorite_only: bool, pool: &SqlitePool) -> RecipeResult&lt;Vec&lt;RecipeReadModel&gt;&gt;</signature>
      <path>crates/recipe/src/read_model.rs</path>
      <usage>List user's recipes in recipe library. Does NOT filter by is_shared - shows both private and shared recipes owned by user.</usage>
      <note>Already implemented. No changes needed for this story.</note>
    </interface>
    <interface>
      <name>list_shared_recipes (NEW - to be implemented)</name>
      <kind>function</kind>
      <signature>pub async fn list_shared_recipes(cuisine: Option&lt;&str&gt;, min_rating: Option&lt;f64&gt;, max_prep_time: Option&lt;u32&gt;, pool: &SqlitePool) -> RecipeResult&lt;Vec&lt;RecipeReadModel&gt;&gt;</signature>
      <path>crates/recipe/src/read_model.rs (create new function)</path>
      <usage>Query shared recipes for community discovery feed. Filter: WHERE is_shared = 1 AND deleted_at IS NULL. Optional filters: cuisine, rating, prep_time. Pagination with LIMIT/OFFSET.</usage>
      <note>New function needed for /discover route. Reference tech-spec lines 1409-1426 for exact SQL.</note>
    </interface>
  </interfaces>

  <tests>
    <standards>
      TDD enforced with 80% coverage goal. Unit tests for domain logic (commands, aggregates, event handlers) using evento::unsafe_oneshot for synchronous projections. Integration tests for HTTP routes with full database setup. E2E tests with Playwright for UI flows (deferred to post-implementation). Testing framework: Rust built-in test framework with tokio::test macro. Database: In-memory SQLite for test isolation. Pattern: Arrange-Act-Assert with clear test names describing behavior.
    </standards>

    <locations>
      - crates/recipe/tests/recipe_tests.rs (unit tests for recipe aggregate and commands)
      - tests/recipe_integration_tests.rs (integration tests for recipe routes with read model)
      - e2e/tests/recipe-management.spec.ts (E2E tests with Playwright - optional for this story)
    </locations>

    <ideas>
      <test ac="2" type="unit">
        test_share_recipe_emits_event: Create recipe, call share_recipe(shared=true), assert RecipeShared event emitted with shared=true, verify aggregate.is_shared = true after event replay
      </test>
      <test ac="2" type="unit">
        test_unshare_recipe_emits_event: Create shared recipe, call share_recipe(shared=false), assert RecipeShared event emitted with shared=false, verify aggregate.is_shared = false
      </test>
      <test ac="5" type="unit">
        test_share_recipe_ownership_check: User A creates recipe, User B attempts share_recipe, expect PermissionDenied error, verify no RecipeShared event emitted
      </test>
      <test ac="2" type="unit">
        test_share_recipe_not_found: Call share_recipe with non-existent recipe_id, expect NotFound error
      </test>
      <test ac="3,12" type="integration">
        test_share_recipe_appears_in_discovery_feed: Create private recipe, share via POST /recipes/:id/share, query GET /discover, verify recipe appears in results with is_shared=true
      </test>
      <test ac="6" type="integration">
        test_unshare_recipe_removes_from_discovery: Create shared recipe, unshare via POST /recipes/:id/share (shared=false), query GET /discover, verify recipe NOT in results
      </test>
      <test ac="10" type="integration">
        test_private_recipe_404_for_non_owner: User A creates private recipe, User B requests GET /recipes/:id, expect 404 response
      </test>
      <test ac="4" type="integration">
        test_shared_recipe_shows_attribution: Create shared recipe, query GET /discover/:id, verify response includes creator username from users table JOIN
      </test>
      <test ac="9" type="integration">
        test_new_recipe_defaults_to_private: Create recipe via POST /recipes, query read model, verify is_shared=false (default)
      </test>
      <test ac="8" type="integration">
        test_profile_shows_shared_count: User has 3 shared recipes and 2 private recipes, query GET /profile, verify "3 Shared Recipes" displayed
      </test>
    </ideas>
  </tests>
</story-context>
