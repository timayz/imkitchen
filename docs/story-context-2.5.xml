<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>5</storyId>
    <title>Automatic Recipe Tagging</title>
    <status>Draft</status>
    <generatedAt>2025-10-14</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>/home/snapiz/projects/github/timayz/imkitchen/docs/stories/story-2.5.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>a user creating a recipe</asA>
    <iWant>the system to automatically tag my recipe</iWant>
    <soThat>I can discover and filter recipes by attributes without manual tagging</soThat>
    <tasks>
      <task id="1" ac="2">Implement complexity calculation algorithm with RecipeComplexityCalculator domain service</task>
      <task id="2" ac="3">Implement cuisine tag inference with pattern matching on ingredient names</task>
      <task id="3" ac="4">Implement dietary tag detection (vegetarian, vegan, gluten-free)</task>
      <task id="4" ac="1,5">Add RecipeTagged event and aggregate field for tag storage</task>
      <task id="5" ac="5,6">Update read model for tag storage with indexed columns</task>
      <task id="6" ac="5">Add tag display to templates (recipe card and detail page)</task>
      <task id="7" ac="6">Add tag filtering to discovery and recipe list routes</task>
      <task id="8" ac="7">Implement manual tag override functionality</task>
      <task id="9">Write unit tests for tagging services (TDD)</task>
      <task id="10">Write integration tests for tag projection (TDD)</task>
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="1">System analyzes recipe data on save</criterion>
    <criterion id="2">Complexity tag assigned based on: ingredient count, instruction steps, advance prep requirements (Simple: &lt;8 ingredients, &lt;6 steps, no advance prep; Moderate: 8-15 ingredients or 6-10 steps; Complex: &gt;15 ingredients or &gt;10 steps or advance prep required)</criterion>
    <criterion id="3">Cuisine tag inferred from ingredient patterns (e.g., soy sauce + ginger = Asian, oregano + tomato = Italian)</criterion>
    <criterion id="4">Dietary tags auto-assigned: vegetarian (no meat/fish), vegan (no animal products), gluten-free (no wheat/flour)</criterion>
    <criterion id="5">Tags displayed on recipe card and detail page</criterion>
    <criterion id="6">Tags used for discovery filtering and meal planning optimization</criterion>
    <criterion id="7">Manual tag override available if auto-tagging incorrect</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc path="docs/solution-architecture.md" section="3.2 Data Models and Relationships">
        <snippet>Event sourcing with evento: RecipeCreated, RecipeUpdated events trigger aggregate rebuilding. CQRS read models materialized via evento subscriptions.</snippet>
      </doc>
      <doc path="docs/solution-architecture.md" section="11.1 Domain Crate Structure">
        <snippet>Domain services are stateless pure functions encapsulating business logic. Called during command handler execution before event emission.</snippet>
      </doc>
      <doc path="docs/epics.md" section="Story 3.12: Recipe Complexity Calculation">
        <snippet>Complexity formula: (ingredients * 0.3) + (steps * 0.4) + (advance_prep_multiplier * 0.3). Thresholds: Simple &lt;30, Moderate 30-60, Complex &gt;60.</snippet>
      </doc>
      <doc path="docs/epics.md" section="Story 2.5: Automatic Recipe Tagging">
        <snippet>Cuisine inference via keyword pattern matching on ingredients. Conservative dietary tag detection (false negatives acceptable, false positives unacceptable).</snippet>
      </doc>
      <doc path="docs/tech-spec-epic-2.md" section="Automatic Tagging">
        <snippet>Tags improve discoverability and feed meal planning algorithm. Meal planning consumes complexity tag for scheduling optimization.</snippet>
      </doc>
      <doc path="docs/solution-architecture.md" section="15 Testing Strategy">
        <snippet>TDD enforced: unit tests for domain logic, integration tests for CRUD operations, E2E tests for user flows. 80% code coverage target.</snippet>
      </doc>
    </docs>

    <code>
      <artifact path="crates/recipe/src/aggregate.rs" kind="struct" symbol="RecipeAggregate" lines="14-39">
        <reason>Existing recipe aggregate structure - need to add tags field and recipe_tagged event handler</reason>
      </artifact>
      <artifact path="crates/recipe/src/events.rs" kind="events" symbol="RecipeCreated, RecipeUpdated, RecipeFavorited" lines="1-80">
        <reason>Existing event definitions - need to add RecipeTagged event following same pattern</reason>
      </artifact>
      <artifact path="crates/recipe/src/aggregate.rs" kind="event-handler" symbol="recipe_created, recipe_updated" lines="53-100">
        <reason>Existing event handlers showing pattern for adding recipe_tagged handler</reason>
      </artifact>
      <artifact path="crates/recipe/src/commands.rs" kind="module" symbol="create_recipe, update_recipe">
        <reason>Command handlers where tagging services will be called after RecipeCreated/RecipeUpdated</reason>
      </artifact>
      <artifact path="crates/recipe/src/read_model.rs" kind="module" symbol="recipe_projection">
        <reason>Existing read model projection handlers - need to add RecipeTagged subscription handler</reason>
      </artifact>
    </code>

    <dependencies>
      <rust>
        <dep name="evento" version="1.3" features="sqlite-migrator">Event sourcing framework</dep>
        <dep name="bincode" version="2.0">Event serialization</dep>
        <dep name="serde" version="1.0" features="derive">Data serialization</dep>
        <dep name="serde_json" version="1.0">JSON handling for dietary_tags array</dep>
        <dep name="sqlx" version="0.8" features="runtime-tokio,sqlite,chrono,uuid">Database access and read model queries</dep>
        <dep name="anyhow" version="1.0">Error handling</dep>
        <dep name="chrono" version="0.4" features="serde">Timestamp handling</dep>
      </rust>
    </dependencies>
  </artifacts>

  <constraints>
    <constraint id="1" category="architecture">Use evento event sourcing: RecipeTagged event emitted after RecipeCreated/RecipeUpdated, tags stored in aggregate and projected to read model</constraint>
    <constraint id="2" category="domain-services">Tagging logic in stateless domain services (RecipeComplexityCalculator, CuisineInferenceService, DietaryTagDetector), NOT in aggregate</constraint>
    <constraint id="3" category="calculation">Complexity formula: (ingredients * 0.3) + (steps * 0.4) + (advance_prep_multiplier * 0.3). advance_prep_multiplier: 0 if none, 50 if &lt;4h, 100 if ≥4h</constraint>
    <constraint id="4" category="pattern-matching">Cuisine inference uses case-insensitive ingredient name matching. Return None if no clear match (no guessing)</constraint>
    <constraint id="5" category="dietary-tags">Conservative approach: only assign vegetarian/vegan/gluten-free tags when confident (no restricted ingredients). False negatives OK, false positives unacceptable</constraint>
    <constraint id="6" category="database">Add columns to recipes table: complexity TEXT, cuisine TEXT, dietary_tags TEXT (JSON array). Create indexes on complexity and cuisine for filtering</constraint>
    <constraint id="7" category="testing">TDD enforced: write tests before implementation. Unit tests for domain services, integration tests for event projection</constraint>
    <constraint id="8" category="logging">Structured logging for all tagging operations (include recipe_id, assigned tags)</constraint>
  </constraints>

  <interfaces>
    <interface name="evento::create" kind="function" path="evento crate">
      <signature>create::&lt;RecipeAggregate&gt;().data(&amp;event).commit(&amp;executor).await</signature>
      <usage>Used in command handlers to emit events</usage>
    </interface>
    <interface name="evento::update" kind="function" path="evento crate">
      <signature>update::&lt;RecipeAggregate&gt;(&amp;recipe_id).data(&amp;event).commit(&amp;executor).await</signature>
      <usage>Emit RecipeTagged event after recipe creation/update</usage>
    </interface>
    <interface name="evento::handler" kind="macro" path="evento crate">
      <signature>#[evento::handler(RecipeAggregate)]</signature>
      <usage>Define subscription handler for RecipeTagged event to project tags to read model</usage>
    </interface>
    <interface name="RecipeAggregate::ingredients" kind="field" path="crates/recipe/src/aggregate.rs">
      <signature>pub ingredients: Vec&lt;Ingredient&gt;</signature>
      <usage>Access ingredient list for cuisine inference and dietary tag detection</usage>
    </interface>
    <interface name="RecipeAggregate::instructions" kind="field" path="crates/recipe/src/aggregate.rs">
      <signature>pub instructions: Vec&lt;InstructionStep&gt;</signature>
      <usage>Count instruction steps for complexity calculation</usage>
    </interface>
    <interface name="RecipeAggregate::advance_prep_hours" kind="field" path="crates/recipe/src/aggregate.rs">
      <signature>pub advance_prep_hours: Option&lt;u32&gt;</signature>
      <usage>Check advance prep requirement for complexity calculation</usage>
    </interface>
  </interfaces>

  <tests>
    <standards>
      TDD enforced with 80% code coverage target. Unit tests in crates/recipe/tests/ for domain logic (aggregate event handlers, domain services). Integration tests in tests/ directory for full event projection flow (command → event → aggregate → subscription → read model → query). E2E tests in e2e/tests/ for user-facing flows (future). Use evento::Executor trait for test isolation with in-memory SQLite database.
    </standards>

    <locations>
      <location>crates/recipe/tests/tagging_tests.rs</location>
      <location>crates/recipe/tests/aggregate_tests.rs</location>
      <location>tests/recipe_tagging_integration_tests.rs</location>
    </locations>

    <ideas>
      <idea ac="2">Test complexity calculation: Simple recipe (5 ingredients, 4 steps, no advance prep) → score &lt; 30 → Complexity::Simple</idea>
      <idea ac="2">Test complexity calculation: Moderate recipe (10 ingredients, 8 steps, no advance prep) → score 30-60 → Complexity::Moderate</idea>
      <idea ac="2">Test complexity calculation: Complex recipe (12 ingredients, 6 steps, 4h advance prep) → score &gt; 60 → Complexity::Complex</idea>
      <idea ac="3">Test cuisine inference: Ingredients ["soy sauce", "ginger", "rice"] → Some("Asian")</idea>
      <idea ac="3">Test cuisine inference: Ingredients ["tomato", "oregano", "pasta"] → Some("Italian")</idea>
      <idea ac="3">Test cuisine inference: Ingredients ["flour", "sugar", "eggs"] → None (no clear match)</idea>
      <idea ac="4">Test dietary tags: Recipe with no meat/fish/dairy → ["vegetarian", "vegan"]</idea>
      <idea ac="4">Test dietary tags: Recipe with eggs but no meat → ["vegetarian"] (not vegan)</idea>
      <idea ac="4">Test dietary tags: Recipe with flour → NOT gluten-free (false positive prevention)</idea>
      <idea ac="1,5">Test RecipeTagged event triggers read model update: tags column populated with complexity, cuisine, dietary_tags</idea>
      <idea ac="6">Test tag filtering query: Query recipes with complexity=simple AND cuisine=italian returns correct subset</idea>
      <idea ac="7">Test manual override: User overrides auto-assigned cuisine → manual_override flag set, auto-tagging skipped on update</idea>
    </ideas>
  </tests>
</story-context>
