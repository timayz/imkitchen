<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>2</epicId>
    <storyId>1</storyId>
    <title>Create Recipe</title>
    <status>Draft</status>
    <generatedAt>2025-10-14</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>/home/snapiz/projects/github/timayz/imkitchen/docs/stories/story-2.1.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>user</asA>
    <iWant>to create a new recipe with all details</iWant>
    <soThat>I can add it to my meal planning rotation</soThat>
    <tasks>
      - Design and implement recipe creation form UI (AC: 1, 2, 3, 4, 5)
      - Implement Recipe domain aggregate and events (AC: 6, 7, 8, 9, 10)
      - Create recipe HTTP route handlers (AC: 6, 7, 8)
      - Implement recipe read model projection (AC: 8)
      - Create recipe detail page (AC: 8)
      - Test recipe creation (AC: 1-10)
    </tasks>
  </story>

  <acceptanceCriteria>
    1. Recipe creation form includes: title, ingredients (quantity/unit/name), step-by-step instructions, prep time, cook time, advance prep requirements, serving size
    2. Ingredients list allows adding/removing rows dynamically
    3. Instructions allow numbered step entry with reordering capability
    4. Each instruction step includes optional timer field (duration in minutes)
    5. Advance prep field accepts text description (e.g., "Marinate 4 hours")
    6. All required fields validated before save
    7. Successful save creates recipe and displays confirmation
    8. User redirected to recipe detail page after creation
    9. Recipe automatically owned by creating user
    10. Default privacy set to "private"
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/solution-architecture.md</path>
        <title>Solution Architecture</title>
        <section>3.2 Data Models and Relationships - Recipe Table Schema</section>
        <snippet>
recipes table:
- id TEXT PRIMARY KEY
- user_id TEXT NOT NULL
- title TEXT NOT NULL
- ingredients TEXT NOT NULL (JSON array of {name, qty, unit})
- instructions TEXT NOT NULL (JSON array of step strings)
- prep_time_min INTEGER
- cook_time_min INTEGER
- advance_prep_hours INTEGER (NULL if no advance prep)
- serving_size INTEGER
- is_favorite BOOLEAN DEFAULT FALSE
- is_shared BOOLEAN DEFAULT FALSE
- complexity TEXT (simple|moderate|complex)
- cuisine TEXT
- created_at TEXT NOT NULL
- updated_at TEXT NOT NULL
- FOREIGN KEY (user_id) REFERENCES users(id)
        </snippet>
      </doc>
      <doc>
        <path>docs/solution-architecture.md</path>
        <title>Solution Architecture</title>
        <section>3.2 Event-to-ReadModel Projections - Recipe Aggregate Example</section>
        <snippet>
// Domain events
#[derive(evento::AggregatorName, bincode::Encode, bincode::Decode)]
struct RecipeCreated {
    title: String,
    ingredients: Vec&lt;Ingredient&gt;,
    // ...
}

// Aggregate
#[derive(Default, Serialize, Deserialize, bincode::Encode, bincode::Decode, Clone, Debug)]
struct Recipe {
    title: String,
    ingredients: Vec&lt;Ingredient&gt;,
    is_favorite: bool,
    // ...
}

// Event handlers (rebuilds aggregate state from events)
#[evento::aggregator]
impl Recipe {
    async fn recipe_created(&amp;mut self, event: EventDetails&lt;RecipeCreated&gt;) -&gt; anyhow::Result&lt;()&gt; {
        self.title = event.data.title;
        self.ingredients = event.data.ingredients;
        Ok(())
    }
}

// Read model projection (subscription handler)
#[evento::handler(Recipe)]
async fn project_recipe_to_read_model&lt;E: evento::Executor&gt;(
    context: &amp;evento::Context&lt;'_, E&gt;,
    event: EventDetails&lt;RecipeCreated&gt;,
) -&gt; anyhow::Result&lt;()&gt; {
    sqlx::query!(
        "INSERT INTO recipes (id, user_id, title, ingredients, created_at) VALUES (?, ?, ?, ?, ?)",
        event.aggregator_id,
        event.metadata,
        event.data.title,
        serde_json::to_string(&amp;event.data.ingredients)?,
        chrono::Utc::now().to_rfc3339()
    )
    .execute(context.executor.pool())
    .await?;
    Ok(())
}
        </snippet>
      </doc>
      <doc>
        <path>docs/solution-architecture.md</path>
        <title>Solution Architecture</title>
        <section>11.1 Domain Crate Structure - Recipe Crate</section>
        <snippet>
crates/recipe/
├── lib.rs
├── aggregate.rs     # RecipeAggregate
├── commands.rs      # CreateRecipe, UpdateRecipe, etc.
├── events.rs        # RecipeCreated, RecipeFavorited, etc.
└── read_model.rs    # Recipe query projections
        </snippet>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-2.md</path>
        <title>Technical Specification: Recipe Management System</title>
        <section>Overview</section>
        <snippet>
Epic 2 delivers the Recipe Management System with full CRUD operations, event sourcing via evento to maintain full audit trails. Key capabilities include recipe creation with ingredients, instructions, timing, and advance preparation requirements.
        </snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic Breakdown</title>
        <section>Story 2.1: Create Recipe</section>
        <snippet>
Prerequisites: User is authenticated
Technical Notes:
- Recipe aggregate with RecipeCreated event
- Ingredients stored as structured data (quantity, unit, ingredient_name)
- Instructions stored as structured data (step_number, instruction_text, optional_timer_minutes)
- Validation: non-empty title, at least 1 ingredient, at least 1 instruction step
- Free tier users limited to 10 recipes total
        </snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>FR-1: Recipe Creation and Storage</section>
        <snippet>
Users can create recipes with title, ingredients (quantities and units), step-by-step instructions, preparation time, cooking time, advance preparation requirements, and serving size. Recipes are stored per-user with optional sharing to community.
        </snippet>
      </doc>
    </docs>

    <code>
      <file>
        <path>crates/user/src/aggregate.rs</path>
        <kind>aggregate-pattern</kind>
        <symbol>UserAggregate</symbol>
        <lines>1-100</lines>
        <reason>Example of evento aggregate pattern - shows how to structure RecipeAggregate with evento::aggregator macro, event handlers, and state management</reason>
      </file>
      <file>
        <path>crates/user/src/events.rs</path>
        <kind>events-pattern</kind>
        <symbol>UserCreated, PasswordChanged, etc.</symbol>
        <lines>N/A</lines>
        <reason>Example of evento event structures using bincode::Encode/Decode - shows how to define RecipeCreated event</reason>
      </file>
      <file>
        <path>crates/user/src/commands.rs</path>
        <kind>commands-pattern</kind>
        <symbol>RegisterUserCommand</symbol>
        <lines>N/A</lines>
        <reason>Example of command structure pattern - shows how to define CreateRecipeCommand with validation</reason>
      </file>
      <file>
        <path>crates/user/src/read_model.rs</path>
        <kind>read-model-pattern</kind>
        <symbol>query_user_by_email, register_user_projection</symbol>
        <lines>N/A</lines>
        <reason>Example of evento subscription handlers and read model queries - shows how to implement recipe read model projection</reason>
      </file>
      <file>
        <path>src/routes/auth.rs</path>
        <kind>route-pattern</kind>
        <symbol>get_register_page, post_register</symbol>
        <lines>1-80</lines>
        <reason>Example of Axum route handlers with Askama templates, form handling, and validation - pattern for recipe creation routes</reason>
      </file>
      <file>
        <path>src/middleware/auth.rs</path>
        <kind>middleware</kind>
        <symbol>Auth</symbol>
        <lines>N/A</lines>
        <reason>Auth middleware that extracts JWT claims - required for recipe ownership validation</reason>
      </file>
      <file>
        <path>templates/pages/register.html</path>
        <kind>template-pattern</kind>
        <symbol>RegisterPageTemplate</symbol>
        <lines>N/A</lines>
        <reason>Example of Askama template structure - pattern for recipe form template</reason>
      </file>
      <file>
        <path>templates/components/form-field.html</path>
        <kind>component</kind>
        <symbol>form-field</symbol>
        <lines>N/A</lines>
        <reason>Reusable form field component for consistent styling - use for recipe form inputs</reason>
      </file>
      <file>
        <path>src/routes/mod.rs</path>
        <kind>router</kind>
        <symbol>create_router</symbol>
        <lines>N/A</lines>
        <reason>Router registration - must add recipe routes here</reason>
      </file>
    </code>

    <dependencies>
      <rust>
        <package name="tokio" version="1.40" features="full" />
        <package name="axum" version="0.8" features="macros" />
        <package name="axum-extra" version="0.10" features="cookie" />
        <package name="askama" version="0.14" />
        <package name="sqlx" version="0.8" features="runtime-tokio, sqlite, chrono, uuid" />
        <package name="evento" version="1.3" features="sqlite-migrator" />
        <package name="validator" version="0.20" features="derive" />
        <package name="serde" version="1.0" features="derive" />
        <package name="serde_json" version="1.0" />
        <package name="uuid" version="1.10" features="v4, serde" />
        <package name="chrono" version="0.4" features="serde" />
        <package name="thiserror" version="1.0" />
        <package name="anyhow" version="1.0" />
        <package name="bincode" version="2.0" />
      </rust>
    </dependencies>
  </artifacts>

  <constraints>
    - MUST use evento event sourcing framework for all state changes
    - MUST follow CQRS pattern: commands write events, queries read from read models
    - MUST implement #[evento::aggregator] macro for RecipeAggregate
    - MUST use bincode::Encode and bincode::Decode for event serialization
    - MUST use SQLx for read model queries (no compile-time verification per architecture decision)
    - MUST use Askama templates for server-side rendering (compile-time type checking)
    - MUST apply auth middleware to all recipe routes (authenticated users only)
    - MUST validate recipe ownership from JWT claims (user_id)
    - MUST enforce free tier 10-recipe limit in CreateRecipe command
    - MUST store ingredients and instructions as JSON in recipes table
    - MUST set default privacy to "private" on creation
    - MUST redirect to recipe detail page after successful creation (PRG pattern)
    - MUST re-render form with validation errors on failure (422 status)
    - MUST use validator crate with derive macros for input validation
    - MUST follow TDD: write tests before implementation
    - MUST achieve 80% code coverage
  </constraints>

  <interfaces>
    <interface>
      <name>Auth Middleware</name>
      <kind>middleware</kind>
      <signature>Extension&lt;Auth&gt; - contains user_id, email, tier from JWT claims</signature>
      <path>src/middleware/auth.rs</path>
      <usage>Extract user_id from Auth extension to set recipe owner</usage>
    </interface>
    <interface>
      <name>AppState</name>
      <kind>state</kind>
      <signature>
pub struct AppState {
    pub db_pool: SqlitePool,
    pub evento_executor: evento::Sqlite,
    pub jwt_secret: String,
    // ...
}
      </signature>
      <path>src/routes/auth.rs</path>
      <usage>Access db_pool for read model queries and evento_executor for event commands</usage>
    </interface>
    <interface>
      <name>evento::create</name>
      <kind>evento-api</kind>
      <signature>
evento::create::&lt;RecipeAggregate&gt;()
    .data(&amp;RecipeCreated { ... })?
    .metadata(&amp;user_id)?
    .commit(&amp;executor)
    .await?
      </signature>
      <path>evento crate</path>
      <usage>Create new Recipe aggregate with RecipeCreated event</usage>
    </interface>
    <interface>
      <name>evento::handler</name>
      <kind>evento-api</kind>
      <signature>
#[evento::handler(RecipeAggregate)]
async fn project_recipe_to_read_model&lt;E: evento::Executor&gt;(
    context: &amp;evento::Context&lt;'_, E&gt;,
    event: EventDetails&lt;RecipeCreated&gt;,
) -&gt; anyhow::Result&lt;()&gt;
      </signature>
      <path>evento crate</path>
      <usage>Register subscription handler for RecipeCreated events to update read model</usage>
    </interface>
  </interfaces>

  <tests>
    <standards>
TDD enforced - write tests before implementation. Test pyramid: unit tests for domain aggregate logic (evento commands/events), integration tests for HTTP routes and database projections, E2E tests with Playwright for full user flows. Use in-memory SQLite for integration tests. Target 80% code coverage via cargo-tarpaulin. All tests must pass before merging.
    </standards>

    <locations>
      - crates/recipe/tests/ - Unit tests for aggregate, commands, events
      - tests/recipe_tests.rs - Integration tests for HTTP routes
      - e2e/tests/recipe-management.spec.ts - Playwright E2E tests
    </locations>

    <ideas>
      <test ac="1,2,3,4,5">Unit test: RecipeAggregate validates required fields (non-empty title, at least 1 ingredient, 1 instruction)</test>
      <test ac="6">Unit test: RecipeCreated event applied correctly to aggregate state</test>
      <test ac="6">Unit test: Free tier recipe limit enforced - 11th recipe creation fails with RecipeCountExceeded error</test>
      <test ac="7,8">Integration test: POST /recipes creates recipe and returns 302 redirect to /recipes/:id</test>
      <test ac="8">Integration test: RecipeCreated event triggers read model projection and inserts into recipes table</test>
      <test ac="8">Integration test: GET /recipes/:id displays created recipe with all fields</test>
      <test ac="6">Integration test: POST /recipes with missing required fields returns 422 with form validation errors</test>
      <test ac="9">Integration test: Recipe owner_id matches authenticated user_id from JWT claims</test>
      <test ac="10">Integration test: Recipe privacy defaults to "private" (is_shared=false)</test>
      <test ac="1-10">E2E test: Complete recipe creation flow - fill form, submit, verify redirect and recipe detail page</test>
      <test ac="2">E2E test: Dynamic ingredient rows - add/remove ingredients in form</test>
      <test ac="6">E2E test: Form validation errors displayed when required fields missing</test>
      <test ac="6">E2E test: Free tier user creates 10 recipes successfully, 11th shows upgrade prompt</test>
    </ideas>
  </tests>
</story-context>
