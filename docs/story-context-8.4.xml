<story-context id="bmad/bmm/workflows/4-implementation/story-context/8.4" v="1.0">
  <metadata>
    <epicId>8</epicId>
    <storyId>8.4</storyId>
    <title>Create Regenerate All Future Weeks Route</title>
    <status>Draft</status>
    <generatedAt>2025-10-26</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>/home/snapiz/projects/github/timayz/imkitchen/docs/stories/story-8.4.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>backend developer</asA>
    <iWant>to create a POST route that regenerates all future weeks while preserving the current week</iWant>
    <soThat>authenticated users can refresh their entire meal plan when preferences or recipe library changes significantly</soThat>
    <tasks>
      - Define route handler function signature with JSON payload (confirmation parameter)
      - Validate confirmation parameter (prevent accidental regeneration)
      - Identify current week (locked) and future weeks
      - Load user's favorite recipes and meal planning preferences
      - Initialize rotation state for regeneration (preserve current week's main courses)
      - Call Epic 7 algorithm to regenerate all future weeks in loop
      - Emit AllFutureWeeksRegenerated evento event
      - Build JSON response with count of regenerated weeks + first future week data
      - Implement error handling for ConfirmationRequired (400)
      - Add structured logging and tracing
      - Write integration tests for successful regeneration, missing confirmation, current week preservation
      - Write performance test (P95 &lt;2000ms route overhead for 4 weeks)
      - Register route in Axum router
    </tasks>
  </story>

  <acceptanceCriteria>
    1. Route `POST /plan/regenerate-all-future` created
    2. Requires confirmation parameter (prevent accidental regeneration)
    3. Handler identifies current week (locked) and preserves it
    4. Handler regenerates all future weeks (`status == "future"`)
    5. Handler resets rotation state but preserves current week's main courses
    6. Handler commits `AllFutureWeeksRegenerated` event to evento
    7. Handler regenerates shopping lists for all future weeks (projection handles this)
    8. Returns count of regenerated weeks + first future week data
    9. Integration test: POST with confirmation regenerates all future weeks
    10. Integration test: POST without confirmation returns 400
  </acceptanceCriteria>

  <artifacts>
    <docs>
      - Technical Specification: /home/snapiz/projects/github/timayz/imkitchen/docs/tech-spec-epic-8.md
        * Section: APIs and Interfaces - POST /plan/regenerate-all-future
        * Section: Workflows and Sequencing - Regenerate All Future Weeks Flow
        * Section: Data Models and Contracts - Regenerate All Future Response
        * Section: Non-Functional Requirements - Performance (P95 &lt;2000ms for 4 weeks)
        * Section: Design Decisions - Confirmation parameter required

      - UX Specification: /home/snapiz/projects/github/timayz/imkitchen/docs/ux-specification.md
        * Section: User Flows - Flow 3: Meal Plan Disruption and Quick Recovery
    </docs>

    <code>
      - Epic 7 Algorithm: /home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/algorithm.rs
        * Function: generate_single_week(recipes, preferences, &amp;mut rotation_state, week_start_date)
        * Call in loop for each future week

      - Rotation State: /home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/rotation.rs
        * RotationState initialization
        * Seed with current week's main course recipe IDs for variety continuation

      - Events: /home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/events.rs
        * AllFutureWeeksRegenerated event struct
        * Fields: generation_batch_id, user_id, weeks, preserved_current_week_id

      - Read Model: /home/snapiz/projects/github/timayz/imkitchen/crates/meal_planning/src/read_model.rs
        * meal_plan_projection handler for AllFutureWeeksRegenerated event
        * Projection: Bulk DELETE old assignments, bulk INSERT new assignments, UPDATE shopping_lists
    </code>

    <dependencies>
      - axum 0.7+ (HTTP routing, Json extractor)
      - sqlx 0.8+ (database queries)
      - evento 1.5+ (event emission)
      - serde, serde_json (JSON deserialization for confirmation parameter)
      - chrono 0.4+ (week date calculations)
      - tracing 0.1+ (structured logging)
    </dependencies>
  </artifacts>

  <constraints>
    - Confirmation Required: Destructive operation requires explicit user confirmation to prevent accidents
    - Current Week Preservation: Week with is_locked == true OR status == "current" never regenerated
    - Rotation State Reset: Start with fresh rotation state, seed with current week's recipes for variety continuation
    - Bulk Algorithm Calls: Loop through future weeks, call generate_single_week for each (not parallel initially)
    - Performance Target: Route overhead P95 &lt;2000ms for 4 weeks (algorithm time excluded)
    - Shopping List Regeneration: Happens asynchronously via evento projection for all future weeks
  </constraints>

  <interfaces>
    Route Signature:
    ```rust
    #[post("/plan/regenerate-all-future")]
    async fn regenerate_all_future_weeks(
        Extension(user_id): Extension&lt;UserId&gt;,
        Json(payload): Json&lt;RegenerateAllPayload&gt;,
        Extension(db): Extension&lt;DatabasePool&gt;,
        Extension(executor): Extension&lt;EventoExecutor&gt;,
    ) -&gt; Result&lt;Json&lt;RegenerateAllResponse&gt;, ApiError&gt;
    ```

    Request Payload:
    ```rust
    #[derive(Debug, Deserialize)]
    pub struct RegenerateAllPayload {
        pub confirmation: bool,
    }
    ```

    Response Schema:
    ```json
    {
      "regenerated_weeks": 4,
      "preserved_current_week_id": "week-uuid-current",
      "first_future_week": {
        "id": "week-uuid-next",
        "start_date": "2025-11-04",
        "meal_assignments": [
          // 21 assignments
        ]
      },
      "message": "All 4 future weeks regenerated successfully. Current week preserved."
    }
    ```

    Error Response:
    ```json
    {
      "error": "ConfirmationRequired",
      "message": "This action requires confirmation. Include { \"confirmation\": true } in request body.",
      "status": 400
    }
    ```

    Implementation Pattern:
    ```rust
    // 1. Validate confirmation
    if !payload.confirmation {
        return Err(ApiError::ConfirmationRequired);
    }

    // 2. Identify current and future weeks
    let weeks: Vec&lt;MealPlanReadModel&gt; = sqlx::query_as(
        "SELECT * FROM meal_plans WHERE user_id = ? AND status IN ('current', 'future') ORDER BY start_date"
    )
    .bind(&user_id)
    .fetch_all(&db)
    .await?;

    let current_week = weeks.iter().find(|w| w.is_locked || w.status == "current");
    let future_weeks: Vec&lt;_&gt; = weeks.iter().filter(|w| w.status == "future" &amp;&amp; !w.is_locked).collect();

    // 3. Initialize rotation state
    let mut rotation_state = RotationState::new();
    if let Some(current) = current_week {
        // Seed with current week's main course recipes
        let current_recipes: Vec&lt;String&gt; = sqlx::query_scalar(
            "SELECT recipe_id FROM meal_assignments WHERE meal_plan_id = ? AND course_type = 'main_course'"
        )
        .bind(&current.id)
        .fetch_all(&db)
        .await?;
        rotation_state.seed_with_recipes(current_recipes);
    }

    // 4. Load recipes and preferences
    let recipes = load_favorite_recipes(&db, &user_id).await?;
    let preferences = load_user_preferences(&db, &user_id).await?;

    // 5. Regenerate all future weeks
    let mut regenerated_weeks = Vec::new();
    for future_week in future_weeks {
        let week_plan = generate_single_week(
            recipes.clone(),
            preferences.clone(),
            &amp;mut rotation_state,
            future_week.start_date
        ).await?;
        regenerated_weeks.push(week_plan);
    }

    // 6. Emit event
    let event = AllFutureWeeksRegenerated {
        generation_batch_id: current_week.unwrap().generation_batch_id.clone(),
        user_id: user_id.to_string(),
        weeks: regenerated_weeks.clone(),
        preserved_current_week_id: current_week.map(|w| w.id.clone()),
    };
    executor.emit(event).await?;

    // 7. Return response
    Ok(Json(RegenerateAllResponse {
        regenerated_weeks: regenerated_weeks.len(),
        preserved_current_week_id: current_week.map(|w| w.id.clone()),
        first_future_week: regenerated_weeks.first().cloned(),
        message: format!("All {} future weeks regenerated successfully. Current week preserved.", regenerated_weeks.len()),
    }))
    ```

    Evento Event Schema:
    ```rust
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct AllFutureWeeksRegenerated {
        pub generation_batch_id: String,            // UUID from current meal plan batch
        pub user_id: String,                        // UUID from JWT claims
        pub weeks: Vec&lt;WeekMealPlanData&gt;,           // All regenerated future weeks (4-5 weeks)
        pub preserved_current_week_id: Option&lt;String&gt;, // Current week UUID (not regenerated)
    }
    ```
  </interfaces>

  <tests>
    <standards>
      - Coverage Target: 100% coverage for confirmation logic and current week preservation (critical business rules)
      - Edge Cases: Zero future weeks, only current week exists, empty confirmation, false confirmation
      - Data Integrity: Verify current week UNCHANGED after regeneration (preservation test)
      - Bulk Operation: Test with realistic scenario (1 current + 4 future weeks)
    </standards>

    <locations>
      - Integration Tests: crates/api/tests/integration/test_regeneration.rs
      - Performance Tests: crates/api/tests/performance/route_latency_tests.rs
    </locations>

    <ideas>
      - Test: POST /plan/regenerate-all-future with confirmation: true returns 200 OK
      - Test: Verify response: regenerated_weeks == 4, preserved_current_week_id matches current week UUID
      - Test: Subscribe to AllFutureWeeksRegenerated event using unsafe_oneshot
      - Test: Verify meal_assignments table has new assignments for all 4 future weeks
      - Test: Verify meal_assignments for current week UNCHANGED (preserved)
      - Test: Verify shopping_lists table updated for all 4 future weeks
      - Test: POST with confirmation: false returns 400 ConfirmationRequired
      - Test: POST with empty body (missing confirmation) returns 400 ConfirmationRequired
      - Test: Setup test database with only current week (no future weeks), verify response: regenerated_weeks == 0
      - Test: Verify current week's specific recipes unchanged after regeneration (exact same recipe IDs)
      - Test: Verify structured logging includes future_weeks_count, regenerated_weeks_count
      - Performance Test: Measure route overhead &lt;2000ms P95 for 4 weeks (mock algorithm to return immediately)
    </ideas>
  </tests>
</story-context>
