importScripts("https://storage.googleapis.com/workbox-cdn/releases/7.1.0/workbox-sw.js");if(workbox){console.log("Workbox loaded successfully");workbox.core.setCacheNameDetails({prefix:"imkitchen",suffix:"v1"});workbox.core.skipWaiting();workbox.core.clientsClaim();workbox.precaching.precacheAndRoute(self.__WB_MANIFEST||[]);workbox.routing.registerRoute(({request})=>request.mode==="navigate",new workbox.strategies.NetworkFirst({cacheName:"pages-v1",plugins:[new workbox.expiration.ExpirationPlugin({maxEntries:50,maxAgeSeconds:7*24*60*60}),new workbox.cacheableResponse.CacheableResponsePlugin({statuses:[0,200]})]}));workbox.routing.registerRoute(({request})=>request.destination==="image",new workbox.strategies.CacheFirst({cacheName:"images-v1",plugins:[new workbox.expiration.ExpirationPlugin({maxEntries:100,maxAgeSeconds:30*24*60*60})]}));workbox.routing.registerRoute(({url})=>url.pathname==="/"||url.pathname.startsWith("/recipes")||url.pathname.startsWith("/calendar")||url.pathname.startsWith("/profile")||url.pathname.startsWith("/community"),new workbox.strategies.NetworkFirst({cacheName:"api-v1",plugins:[new workbox.expiration.ExpirationPlugin({maxEntries:100,maxAgeSeconds:24*60*60})]}));workbox.routing.registerRoute(({request})=>request.destination==="style"||request.destination==="script"||request.destination==="font",new workbox.strategies.CacheFirst({cacheName:"static-v1",plugins:[new workbox.expiration.ExpirationPlugin({maxEntries:60,maxAgeSeconds:365*24*60*60})]}));const OFFLINE_FALLBACK_URL="/offline";self.addEventListener("install",event=>{event.waitUntil(Promise.all([caches.open("pages-v1").then(cache=>{return cache.add(OFFLINE_FALLBACK_URL)}),checkStorageQuota()]))});workbox.routing.setCatchHandler(({event})=>{if(event.request.mode==="navigate"){return caches.match(OFFLINE_FALLBACK_URL)}return Response.error()});async function checkStorageQuota(){if("storage"in navigator&&"estimate"in navigator.storage){try{const estimate=await navigator.storage.estimate();const usage=estimate.usage||0;const quota=estimate.quota||0;const percentUsed=quota>0?usage/quota*100:0;console.log(`Storage: ${(usage/1024/1024).toFixed(2)} MB used of ${(quota/1024/1024).toFixed(2)} MB (${percentUsed.toFixed(1)}%)`);if(percentUsed>90){console.warn("Storage quota critical: "+percentUsed.toFixed(1)+"% used. Consider clearing old caches.")}else if(percentUsed>75){console.warn("Storage quota high: "+percentUsed.toFixed(1)+"% used.")}return estimate}catch(error){console.error("Failed to check storage quota:",error)}}else{console.log("Storage estimation API not available")}}}else{console.error("Workbox failed to load")}self.addEventListener("push",event=>{console.log("Push notification received:",event);let data={title:"Prep Reminder",body:"Time to start preparing your meal",icon:"/static/icons/icon-192.png",badge:"/static/icons/badge-72.png",data:{url:"/notifications"}};if(event.data){try{data=event.data.json()}catch(e){console.error("Failed to parse push data:",e)}}const options={body:data.body,icon:data.icon||"/static/icons/icon-192.png",badge:data.badge||"/static/icons/badge-72.png",data:data.data||{url:"/notifications"},actions:data.actions||[{action:"view",title:"View Recipe"},{action:"dismiss",title:"Dismiss"}],vibrate:[200,100,200],requireInteraction:false,tag:"prep-reminder"};event.waitUntil(self.registration.showNotification(data.title,options))});self.addEventListener("notificationclick",event=>{console.log("Notification clicked:",event);event.notification.close();const urlToOpen=event.notification.data?.url||"/notifications";event.waitUntil(clients.matchAll({type:"window",includeUncontrolled:true}).then(clientList=>{for(const client of clientList){if(client.url.includes(self.location.origin)&&"focus"in client){client.focus();client.navigate(urlToOpen);return}}if(clients.openWindow){return clients.openWindow(urlToOpen)}}))});self.addEventListener("notificationclose",event=>{console.log("Notification closed:",event)});self.addEventListener("sync",event=>{console.log("Background sync triggered:",event.tag);if(event.tag==="sync-offline-actions"){event.waitUntil(syncOfflineActions())}});async function syncOfflineActions(){try{const db=await openSyncDatabase();const requests=await getAllQueuedRequests(db);console.log(`Syncing ${requests.length} queued requests`);for(const queuedRequest of requests){try{await replayRequest(queuedRequest);await removeQueuedRequest(db,queuedRequest.id);console.log("Successfully synced request:",queuedRequest.id)}catch(error){console.error("Failed to sync request:",queuedRequest.id,error);await incrementRetryCount(db,queuedRequest.id)}}console.log("Background sync completed")}catch(error){console.error("Background sync failed:",error);throw error}}function openSyncDatabase(){return new Promise((resolve,reject)=>{const request=indexedDB.open("imkitchen-sync",1);request.onerror=()=>reject(request.error);request.onsuccess=()=>resolve(request.result);request.onupgradeneeded=event=>{const db=event.target.result;if(!db.objectStoreNames.contains("queue")){const store=db.createObjectStore("queue",{keyPath:"id",autoIncrement:true});store.createIndex("timestamp","timestamp",{unique:false});store.createIndex("retryCount","retryCount",{unique:false})}}})}function getAllQueuedRequests(db){return new Promise((resolve,reject)=>{const transaction=db.transaction(["queue"],"readonly");const store=transaction.objectStore("queue");const request=store.getAll();request.onsuccess=()=>resolve(request.result||[]);request.onerror=()=>reject(request.error)})}async function replayRequest(queuedRequest){const{url,method,body,headers}=queuedRequest;const response=await fetch(url,{method:method,headers:headers||{},body:body?JSON.stringify(body):undefined});if(!response.ok){throw new Error(`Request failed with status ${response.status}`)}return response}function removeQueuedRequest(db,id){return new Promise((resolve,reject)=>{const transaction=db.transaction(["queue"],"readwrite");const store=transaction.objectStore("queue");const request=store.delete(id);request.onsuccess=()=>resolve();request.onerror=()=>reject(request.error)})}function incrementRetryCount(db,id){return new Promise((resolve,reject)=>{const transaction=db.transaction(["queue"],"readwrite");const store=transaction.objectStore("queue");const getRequest=store.get(id);getRequest.onsuccess=()=>{const record=getRequest.result;if(record){record.retryCount=(record.retryCount||0)+1;if(record.retryCount>=3){store.delete(id);console.warn("Max retries exceeded for request:",id)}else{store.put(record)}}resolve()};getRequest.onerror=()=>reject(getRequest.error)})}